<html>
<head>
<title>version.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
version.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2012-2017 The Python Software Foundation.</span>
<span class="s0"># See LICENSE.txt and CONTRIBUTORS.txt.</span>
<span class="s0">#</span>
<span class="s2">&quot;&quot;&quot; 
Implementation of a flexible versioning scheme providing support for PEP-440, 
setuptools-compatible and semantic versioning. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">re</span>

<span class="s3">from </span><span class="s1">.compat </span><span class="s3">import </span><span class="s1">string_types</span>
<span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">parse_requirement</span>

<span class="s1">__all__ = [</span><span class="s4">'NormalizedVersion'</span><span class="s3">, </span><span class="s4">'NormalizedMatcher'</span><span class="s3">,</span>
           <span class="s4">'LegacyVersion'</span><span class="s3">, </span><span class="s4">'LegacyMatcher'</span><span class="s3">,</span>
           <span class="s4">'SemanticVersion'</span><span class="s3">, </span><span class="s4">'SemanticMatcher'</span><span class="s3">,</span>
           <span class="s4">'UnsupportedVersionError'</span><span class="s3">, </span><span class="s4">'get_scheme'</span><span class="s1">]</span>

<span class="s1">logger = logging.getLogger(__name__)</span>


<span class="s3">class </span><span class="s1">UnsupportedVersionError(ValueError):</span>
    <span class="s2">&quot;&quot;&quot;This is an unsupported version.&quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">Version(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s1">self._string = s = s.strip()</span>
        <span class="s1">self._parts = parts = self.parse(s)</span>
        <span class="s3">assert </span><span class="s1">isinstance(parts</span><span class="s3">, </span><span class="s1">tuple)</span>
        <span class="s3">assert </span><span class="s1">len(parts) &gt; </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">parse(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'please implement in a subclass'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_compatible(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">type(self) != type(other):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'cannot compare %r and %r' </span><span class="s1">% (self</span><span class="s3">, </span><span class="s1">other))</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">self._check_compatible(other)</span>
        <span class="s3">return </span><span class="s1">self._parts == other._parts</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">self._check_compatible(other)</span>
        <span class="s3">return </span><span class="s1">self._parts &lt; other._parts</span>

    <span class="s3">def </span><span class="s1">__gt__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">(self.__lt__(other) </span><span class="s3">or </span><span class="s1">self.__eq__(other))</span>

    <span class="s3">def </span><span class="s1">__le__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self.__lt__(other) </span><span class="s3">or </span><span class="s1">self.__eq__(other)</span>

    <span class="s3">def </span><span class="s1">__ge__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self.__gt__(other) </span><span class="s3">or </span><span class="s1">self.__eq__(other)</span>

    <span class="s0"># See http://docs.python.org/reference/datamodel#object.__hash__</span>
    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">hash(self._parts)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">&quot;%s('%s')&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">self._string)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">self._string</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_prerelease(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Please implement in subclasses.'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">Matcher(object):</span>
    <span class="s1">version_class = </span><span class="s3">None</span>

    <span class="s0"># value is either a callable or the name of a method</span>
    <span class="s1">_operators = {</span>
        <span class="s4">'&lt;'</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v &lt; c</span><span class="s3">,</span>
        <span class="s4">'&gt;'</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v &gt; c</span><span class="s3">,</span>
        <span class="s4">'&lt;='</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v == c </span><span class="s3">or </span><span class="s1">v &lt; c</span><span class="s3">,</span>
        <span class="s4">'&gt;='</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v == c </span><span class="s3">or </span><span class="s1">v &gt; c</span><span class="s3">,</span>
        <span class="s4">'=='</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v == c</span><span class="s3">,</span>
        <span class="s4">'==='</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v == c</span><span class="s3">,</span>
        <span class="s0"># by default, compatible =&gt; &gt;=.</span>
        <span class="s4">'~='</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v == c </span><span class="s3">or </span><span class="s1">v &gt; c</span><span class="s3">,</span>
        <span class="s4">'!='</span><span class="s1">: </span><span class="s3">lambda </span><span class="s1">v</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">p: v != c</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s0"># this is a method only to support alternative implementations</span>
    <span class="s0"># via overriding</span>
    <span class="s3">def </span><span class="s1">parse_requirement(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">return </span><span class="s1">parse_requirement(s)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">if </span><span class="s1">self.version_class </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Please specify a version class'</span><span class="s1">)</span>
        <span class="s1">self._string = s = s.strip()</span>
        <span class="s1">r = self.parse_requirement(s)</span>
        <span class="s3">if not </span><span class="s1">r:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Not valid: %r' </span><span class="s1">% s)</span>
        <span class="s1">self.name = r.name</span>
        <span class="s1">self.key = self.name.lower()    </span><span class="s0"># for case-insensitive comparisons</span>
        <span class="s1">clist = []</span>
        <span class="s3">if </span><span class="s1">r.constraints:</span>
            <span class="s0"># import pdb; pdb.set_trace()</span>
            <span class="s3">for </span><span class="s1">op</span><span class="s3">, </span><span class="s1">s </span><span class="s3">in </span><span class="s1">r.constraints:</span>
                <span class="s3">if </span><span class="s1">s.endswith(</span><span class="s4">'.*'</span><span class="s1">):</span>
                    <span class="s3">if </span><span class="s1">op </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s4">'!='</span><span class="s1">):</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'</span><span class="s3">\'</span><span class="s4">.*</span><span class="s3">\' </span><span class="s4">not allowed for '</span>
                                         <span class="s4">'%r constraints' </span><span class="s1">% op)</span>
                    <span class="s0"># Could be a partial version (e.g. for '2.*') which</span>
                    <span class="s0"># won't parse as a version, so keep it as a string</span>
                    <span class="s1">vn</span><span class="s3">, </span><span class="s1">prefix = s[:-</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, True</span>
                    <span class="s0"># Just to check that vn is a valid version</span>
                    <span class="s1">self.version_class(vn)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s0"># Should parse as a version, so we can create an</span>
                    <span class="s0"># instance for the comparison</span>
                    <span class="s1">vn</span><span class="s3">, </span><span class="s1">prefix = self.version_class(s)</span><span class="s3">, False</span>
                <span class="s1">clist.append((op</span><span class="s3">, </span><span class="s1">vn</span><span class="s3">, </span><span class="s1">prefix))</span>
        <span class="s1">self._parts = tuple(clist)</span>

    <span class="s3">def </span><span class="s1">match(self</span><span class="s3">, </span><span class="s1">version):</span>
        <span class="s2">&quot;&quot;&quot; 
        Check if the provided version matches the constraints. 
 
        :param version: The version to match against this instance. 
        :type version: String or :class:`Version` instance. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(version</span><span class="s3">, </span><span class="s1">string_types):</span>
            <span class="s1">version = self.version_class(version)</span>
        <span class="s3">for </span><span class="s1">operator</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix </span><span class="s3">in </span><span class="s1">self._parts:</span>
            <span class="s1">f = self._operators.get(operator)</span>
            <span class="s3">if </span><span class="s1">isinstance(f</span><span class="s3">, </span><span class="s1">string_types):</span>
                <span class="s1">f = getattr(self</span><span class="s3">, </span><span class="s1">f)</span>
            <span class="s3">if not </span><span class="s1">f:</span>
                <span class="s1">msg = (</span><span class="s4">'%r not implemented '</span>
                       <span class="s4">'for %s' </span><span class="s1">% (operator</span><span class="s3">, </span><span class="s1">self.__class__.__name__))</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError(msg)</span>
            <span class="s3">if not </span><span class="s1">f(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
                <span class="s3">return False</span>
        <span class="s3">return True</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">exact_version(self):</span>
        <span class="s1">result = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">len(self._parts) == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">self._parts[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">(</span><span class="s4">'=='</span><span class="s3">, </span><span class="s4">'==='</span><span class="s1">):</span>
            <span class="s1">result = self._parts[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_check_compatible(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">type(self) != type(other) </span><span class="s3">or </span><span class="s1">self.name != other.name:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'cannot compare %s and %s' </span><span class="s1">% (self</span><span class="s3">, </span><span class="s1">other))</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">self._check_compatible(other)</span>
        <span class="s3">return </span><span class="s1">self.key == other.key </span><span class="s3">and </span><span class="s1">self._parts == other._parts</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s0"># See http://docs.python.org/reference/datamodel#object.__hash__</span>
    <span class="s3">def </span><span class="s1">__hash__(self):</span>
        <span class="s3">return </span><span class="s1">hash(self.key) + hash(self._parts)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">&quot;%s(%r)&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">self._string)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">self._string</span>


<span class="s1">PEP440_VERSION_RE = re.compile(</span><span class="s4">r'^v?(\d+!)?(\d+(\.\d+)*)((a|b|c|rc)(\d+))?'</span>
                               <span class="s4">r'(\.(post)(\d+))?(\.(dev)(\d+))?'</span>
                               <span class="s4">r'(\+([a-zA-Z\d]+(\.[a-zA-Z\d]+)?))?$'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_pep_440_key(s):</span>
    <span class="s1">s = s.strip()</span>
    <span class="s1">m = PEP440_VERSION_RE.match(s)</span>
    <span class="s3">if not </span><span class="s1">m:</span>
        <span class="s3">raise </span><span class="s1">UnsupportedVersionError(</span><span class="s4">'Not a valid version: %s' </span><span class="s1">% s)</span>
    <span class="s1">groups = m.groups()</span>
    <span class="s1">nums = tuple(int(v) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">groups[</span><span class="s5">1</span><span class="s1">].split(</span><span class="s4">'.'</span><span class="s1">))</span>
    <span class="s3">while </span><span class="s1">len(nums) &gt; </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">nums[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">nums = nums[:-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">if not </span><span class="s1">groups[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s1">epoch = </span><span class="s5">0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">epoch = int(groups[</span><span class="s5">0</span><span class="s1">][:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">pre = groups[</span><span class="s5">4</span><span class="s1">:</span><span class="s5">6</span><span class="s1">]</span>
    <span class="s1">post = groups[</span><span class="s5">7</span><span class="s1">:</span><span class="s5">9</span><span class="s1">]</span>
    <span class="s1">dev = groups[</span><span class="s5">10</span><span class="s1">:</span><span class="s5">12</span><span class="s1">]</span>
    <span class="s1">local = groups[</span><span class="s5">13</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">pre == (</span><span class="s3">None, None</span><span class="s1">):</span>
        <span class="s1">pre = ()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">pre = pre[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int(pre[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">post == (</span><span class="s3">None, None</span><span class="s1">):</span>
        <span class="s1">post = ()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">post = post[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int(post[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">dev == (</span><span class="s3">None, None</span><span class="s1">):</span>
        <span class="s1">dev = ()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">dev = dev[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int(dev[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">local </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">local = ()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">parts = []</span>
        <span class="s3">for </span><span class="s1">part </span><span class="s3">in </span><span class="s1">local.split(</span><span class="s4">'.'</span><span class="s1">):</span>
            <span class="s0"># to ensure that numeric compares as &gt; lexicographic, avoid</span>
            <span class="s0"># comparing them directly, but encode a tuple which ensures</span>
            <span class="s0"># correct sorting</span>
            <span class="s3">if </span><span class="s1">part.isdigit():</span>
                <span class="s1">part = (</span><span class="s5">1</span><span class="s3">, </span><span class="s1">int(part))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">part = (</span><span class="s5">0</span><span class="s3">, </span><span class="s1">part)</span>
            <span class="s1">parts.append(part)</span>
        <span class="s1">local = tuple(parts)</span>
    <span class="s3">if not </span><span class="s1">pre:</span>
        <span class="s0"># either before pre-release, or final release and after</span>
        <span class="s3">if not </span><span class="s1">post </span><span class="s3">and </span><span class="s1">dev:</span>
            <span class="s0"># before pre-release</span>
            <span class="s1">pre = (</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)     </span><span class="s0"># to sort before a0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pre = (</span><span class="s4">'z'</span><span class="s3">,</span><span class="s1">)        </span><span class="s0"># to sort after all pre-releases</span>
    <span class="s0"># now look at the state of post and dev.</span>
    <span class="s3">if not </span><span class="s1">post:</span>
        <span class="s1">post = (</span><span class="s4">'_'</span><span class="s3">,</span><span class="s1">)   </span><span class="s0"># sort before 'a'</span>
    <span class="s3">if not </span><span class="s1">dev:</span>
        <span class="s1">dev = (</span><span class="s4">'final'</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s0">#print('%s -&gt; %s' % (s, m.groups()))</span>
    <span class="s3">return </span><span class="s1">epoch</span><span class="s3">, </span><span class="s1">nums</span><span class="s3">, </span><span class="s1">pre</span><span class="s3">, </span><span class="s1">post</span><span class="s3">, </span><span class="s1">dev</span><span class="s3">, </span><span class="s1">local</span>


<span class="s1">_normalized_key = _pep_440_key</span>


<span class="s3">class </span><span class="s1">NormalizedVersion(Version):</span>
    <span class="s2">&quot;&quot;&quot;A rational version. 
 
    Good: 
        1.2         # equivalent to &quot;1.2.0&quot; 
        1.2.0 
        1.2a1 
        1.2.3a2 
        1.2.3b1 
        1.2.3c1 
        1.2.3.4 
        TODO: fill this out 
 
    Bad: 
        1           # minimum two numbers 
        1.2a        # release level must have a release serial 
        1.2.3b 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">parse(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s1">result = _normalized_key(s)</span>
        <span class="s0"># _normalized_key loses trailing zeroes in the release</span>
        <span class="s0"># clause, since that's needed to ensure that X.Y == X.Y.0 == X.Y.0.0</span>
        <span class="s0"># However, PEP 440 prefix matching needs it: for example,</span>
        <span class="s0"># (~= 1.4.5.0) matches differently to (~= 1.4.5.0.0).</span>
        <span class="s1">m = PEP440_VERSION_RE.match(s)      </span><span class="s0"># must succeed</span>
        <span class="s1">groups = m.groups()</span>
        <span class="s1">self._release_clause = tuple(int(v) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">groups[</span><span class="s5">1</span><span class="s1">].split(</span><span class="s4">'.'</span><span class="s1">))</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s1">PREREL_TAGS = set([</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'b'</span><span class="s3">, </span><span class="s4">'c'</span><span class="s3">, </span><span class="s4">'rc'</span><span class="s3">, </span><span class="s4">'dev'</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_prerelease(self):</span>
        <span class="s3">return </span><span class="s1">any(t[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">self.PREREL_TAGS </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">self._parts </span><span class="s3">if </span><span class="s1">t)</span>


<span class="s3">def </span><span class="s1">_match_prefix(x</span><span class="s3">, </span><span class="s1">y):</span>
    <span class="s1">x = str(x)</span>
    <span class="s1">y = str(y)</span>
    <span class="s3">if </span><span class="s1">x == y:</span>
        <span class="s3">return True</span>
    <span class="s3">if not </span><span class="s1">x.startswith(y):</span>
        <span class="s3">return False</span>
    <span class="s1">n = len(y)</span>
    <span class="s3">return </span><span class="s1">x[n] == </span><span class="s4">'.'</span>


<span class="s3">class </span><span class="s1">NormalizedMatcher(Matcher):</span>
    <span class="s1">version_class = NormalizedVersion</span>

    <span class="s0"># value is either a callable or the name of a method</span>
    <span class="s1">_operators = {</span>
        <span class="s4">'~='</span><span class="s1">: </span><span class="s4">'_match_compatible'</span><span class="s3">,</span>
        <span class="s4">'&lt;'</span><span class="s1">: </span><span class="s4">'_match_lt'</span><span class="s3">,</span>
        <span class="s4">'&gt;'</span><span class="s1">: </span><span class="s4">'_match_gt'</span><span class="s3">,</span>
        <span class="s4">'&lt;='</span><span class="s1">: </span><span class="s4">'_match_le'</span><span class="s3">,</span>
        <span class="s4">'&gt;='</span><span class="s1">: </span><span class="s4">'_match_ge'</span><span class="s3">,</span>
        <span class="s4">'=='</span><span class="s1">: </span><span class="s4">'_match_eq'</span><span class="s3">,</span>
        <span class="s4">'==='</span><span class="s1">: </span><span class="s4">'_match_arbitrary'</span><span class="s3">,</span>
        <span class="s4">'!='</span><span class="s1">: </span><span class="s4">'_match_ne'</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">_adjust_local(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s3">if </span><span class="s1">prefix:</span>
            <span class="s1">strip_local = </span><span class="s4">'+' </span><span class="s3">not in </span><span class="s1">constraint </span><span class="s3">and </span><span class="s1">version._parts[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># both constraint and version are</span>
            <span class="s0"># NormalizedVersion instances.</span>
            <span class="s0"># If constraint does not have a local component,</span>
            <span class="s0"># ensure the version doesn't, either.</span>
            <span class="s1">strip_local = </span><span class="s3">not </span><span class="s1">constraint._parts[-</span><span class="s5">1</span><span class="s1">] </span><span class="s3">and </span><span class="s1">version._parts[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">strip_local:</span>
            <span class="s1">s = version._string.split(</span><span class="s4">'+'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">version = self.version_class(s)</span>
        <span class="s3">return </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span>

    <span class="s3">def </span><span class="s1">_match_lt(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s1">version</span><span class="s3">, </span><span class="s1">constraint = self._adjust_local(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">if </span><span class="s1">version &gt;= constraint:</span>
            <span class="s3">return False</span>
        <span class="s1">release_clause = constraint._release_clause</span>
        <span class="s1">pfx = </span><span class="s4">'.'</span><span class="s1">.join([str(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">release_clause])</span>
        <span class="s3">return not </span><span class="s1">_match_prefix(version</span><span class="s3">, </span><span class="s1">pfx)</span>

    <span class="s3">def </span><span class="s1">_match_gt(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s1">version</span><span class="s3">, </span><span class="s1">constraint = self._adjust_local(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">if </span><span class="s1">version &lt;= constraint:</span>
            <span class="s3">return False</span>
        <span class="s1">release_clause = constraint._release_clause</span>
        <span class="s1">pfx = </span><span class="s4">'.'</span><span class="s1">.join([str(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">release_clause])</span>
        <span class="s3">return not </span><span class="s1">_match_prefix(version</span><span class="s3">, </span><span class="s1">pfx)</span>

    <span class="s3">def </span><span class="s1">_match_le(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s1">version</span><span class="s3">, </span><span class="s1">constraint = self._adjust_local(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">return </span><span class="s1">version &lt;= constraint</span>

    <span class="s3">def </span><span class="s1">_match_ge(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s1">version</span><span class="s3">, </span><span class="s1">constraint = self._adjust_local(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">return </span><span class="s1">version &gt;= constraint</span>

    <span class="s3">def </span><span class="s1">_match_eq(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s1">version</span><span class="s3">, </span><span class="s1">constraint = self._adjust_local(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">if not </span><span class="s1">prefix:</span>
            <span class="s1">result = (version == constraint)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">result = _match_prefix(version</span><span class="s3">, </span><span class="s1">constraint)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_match_arbitrary(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s3">return </span><span class="s1">str(version) == str(constraint)</span>

    <span class="s3">def </span><span class="s1">_match_ne(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s1">version</span><span class="s3">, </span><span class="s1">constraint = self._adjust_local(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">if not </span><span class="s1">prefix:</span>
            <span class="s1">result = (version != constraint)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">result = </span><span class="s3">not </span><span class="s1">_match_prefix(version</span><span class="s3">, </span><span class="s1">constraint)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_match_compatible(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s1">version</span><span class="s3">, </span><span class="s1">constraint = self._adjust_local(version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix)</span>
        <span class="s3">if </span><span class="s1">version == constraint:</span>
            <span class="s3">return True</span>
        <span class="s3">if </span><span class="s1">version &lt; constraint:</span>
            <span class="s3">return False</span>
<span class="s0">#        if not prefix:</span>
<span class="s0">#            return True</span>
        <span class="s1">release_clause = constraint._release_clause</span>
        <span class="s3">if </span><span class="s1">len(release_clause) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">release_clause = release_clause[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">pfx = </span><span class="s4">'.'</span><span class="s1">.join([str(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">release_clause])</span>
        <span class="s3">return </span><span class="s1">_match_prefix(version</span><span class="s3">, </span><span class="s1">pfx)</span>

<span class="s1">_REPLACEMENTS = (</span>
    <span class="s1">(re.compile(</span><span class="s4">'[.+-]$'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,                     </span><span class="s0"># remove trailing puncts</span>
    <span class="s1">(re.compile(</span><span class="s4">r'^[.](\d)'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">r'0.\1'</span><span class="s1">)</span><span class="s3">,             </span><span class="s0"># .N -&gt; 0.N at start</span>
    <span class="s1">(re.compile(</span><span class="s4">'^[.-]'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,                      </span><span class="s0"># remove leading puncts</span>
    <span class="s1">(re.compile(</span><span class="s4">r'^\((.*)\)$'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">r'\1'</span><span class="s1">)</span><span class="s3">,             </span><span class="s0"># remove parentheses</span>
    <span class="s1">(re.compile(</span><span class="s4">r'^v(ersion)?\s*(\d+)'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">r'\2'</span><span class="s1">)</span><span class="s3">,    </span><span class="s0"># remove leading v(ersion)</span>
    <span class="s1">(re.compile(</span><span class="s4">r'^r(ev)?\s*(\d+)'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">r'\2'</span><span class="s1">)</span><span class="s3">,        </span><span class="s0"># remove leading v(ersion)</span>
    <span class="s1">(re.compile(</span><span class="s4">'[.]{2,}'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'.'</span><span class="s1">)</span><span class="s3">,                   </span><span class="s0"># multiple runs of '.'</span>
    <span class="s1">(re.compile(</span><span class="s4">r'\b(alfa|apha)\b'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'alpha'</span><span class="s1">)</span><span class="s3">,      </span><span class="s0"># misspelt alpha</span>
    <span class="s1">(re.compile(</span><span class="s4">r'\b(pre-alpha|prealpha)\b'</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s4">'pre.alpha'</span><span class="s1">)</span><span class="s3">,                       </span><span class="s0"># standardise</span>
    <span class="s1">(re.compile(</span><span class="s4">r'\(beta\)$'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'beta'</span><span class="s1">)</span><span class="s3">,             </span><span class="s0"># remove parentheses</span>
<span class="s1">)</span>

<span class="s1">_SUFFIX_REPLACEMENTS = (</span>
    <span class="s1">(re.compile(</span><span class="s4">'^[:~._+-]+'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,                   </span><span class="s0"># remove leading puncts</span>
    <span class="s1">(re.compile(</span><span class="s4">'[,*&quot;)([</span><span class="s3">\\</span><span class="s4">]]'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,                  </span><span class="s0"># remove unwanted chars</span>
    <span class="s1">(re.compile(</span><span class="s4">'[~:+_ -]'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'.'</span><span class="s1">)</span><span class="s3">,                    </span><span class="s0"># replace illegal chars</span>
    <span class="s1">(re.compile(</span><span class="s4">'[.]{2,}'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">'.'</span><span class="s1">)</span><span class="s3">,                   </span><span class="s0"># multiple runs of '.'</span>
    <span class="s1">(re.compile(</span><span class="s4">r'\.$'</span><span class="s1">)</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,                       </span><span class="s0"># trailing '.'</span>
<span class="s1">)</span>

<span class="s1">_NUMERIC_PREFIX = re.compile(</span><span class="s4">r'(\d+(\.\d+)*)'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_suggest_semantic_version(s):</span>
    <span class="s2">&quot;&quot;&quot; 
    Try to suggest a semantic form for a version for which 
    _suggest_normalized_version couldn't come up with anything. 
    &quot;&quot;&quot;</span>
    <span class="s1">result = s.strip().lower()</span>
    <span class="s3">for </span><span class="s1">pat</span><span class="s3">, </span><span class="s1">repl </span><span class="s3">in </span><span class="s1">_REPLACEMENTS:</span>
        <span class="s1">result = pat.sub(repl</span><span class="s3">, </span><span class="s1">result)</span>
    <span class="s3">if not </span><span class="s1">result:</span>
        <span class="s1">result = </span><span class="s4">'0.0.0'</span>

    <span class="s0"># Now look for numeric prefix, and separate it out from</span>
    <span class="s0"># the rest.</span>
    <span class="s0">#import pdb; pdb.set_trace()</span>
    <span class="s1">m = _NUMERIC_PREFIX.match(result)</span>
    <span class="s3">if not </span><span class="s1">m:</span>
        <span class="s1">prefix = </span><span class="s4">'0.0.0'</span>
        <span class="s1">suffix = result</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">prefix = m.groups()[</span><span class="s5">0</span><span class="s1">].split(</span><span class="s4">'.'</span><span class="s1">)</span>
        <span class="s1">prefix = [int(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">prefix]</span>
        <span class="s3">while </span><span class="s1">len(prefix) &lt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">prefix.append(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(prefix) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">suffix = result[m.end():]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">suffix = </span><span class="s4">'.'</span><span class="s1">.join([str(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">prefix[</span><span class="s5">3</span><span class="s1">:]]) + result[m.end():]</span>
            <span class="s1">prefix = prefix[:</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s1">prefix = </span><span class="s4">'.'</span><span class="s1">.join([str(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">prefix])</span>
        <span class="s1">suffix = suffix.strip()</span>
    <span class="s3">if </span><span class="s1">suffix:</span>
        <span class="s0">#import pdb; pdb.set_trace()</span>
        <span class="s0"># massage the suffix.</span>
        <span class="s3">for </span><span class="s1">pat</span><span class="s3">, </span><span class="s1">repl </span><span class="s3">in </span><span class="s1">_SUFFIX_REPLACEMENTS:</span>
            <span class="s1">suffix = pat.sub(repl</span><span class="s3">, </span><span class="s1">suffix)</span>

    <span class="s3">if not </span><span class="s1">suffix:</span>
        <span class="s1">result = prefix</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">sep = </span><span class="s4">'-' </span><span class="s3">if </span><span class="s4">'dev' </span><span class="s3">in </span><span class="s1">suffix </span><span class="s3">else </span><span class="s4">'+'</span>
        <span class="s1">result = prefix + sep + suffix</span>
    <span class="s3">if not </span><span class="s1">is_semver(result):</span>
        <span class="s1">result = </span><span class="s3">None</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">_suggest_normalized_version(s):</span>
    <span class="s2">&quot;&quot;&quot;Suggest a normalized version close to the given version string. 
 
    If you have a version string that isn't rational (i.e. NormalizedVersion 
    doesn't like it) then you might be able to get an equivalent (or close) 
    rational version from this function. 
 
    This does a number of simple normalizations to the given string, based 
    on observation of versions currently in use on PyPI. Given a dump of 
    those version during PyCon 2009, 4287 of them: 
    - 2312 (53.93%) match NormalizedVersion without change 
      with the automatic suggestion 
    - 3474 (81.04%) match when using this suggestion method 
 
    @param s {str} An irrational version string. 
    @returns A rational version string, or None, if couldn't determine one. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">_normalized_key(s)</span>
        <span class="s3">return </span><span class="s1">s   </span><span class="s0"># already rational</span>
    <span class="s3">except </span><span class="s1">UnsupportedVersionError:</span>
        <span class="s3">pass</span>

    <span class="s1">rs = s.lower()</span>

    <span class="s0"># part of this could use maketrans</span>
    <span class="s3">for </span><span class="s1">orig</span><span class="s3">, </span><span class="s1">repl </span><span class="s3">in </span><span class="s1">((</span><span class="s4">'-alpha'</span><span class="s3">, </span><span class="s4">'a'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'-beta'</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'alpha'</span><span class="s3">, </span><span class="s4">'a'</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">(</span><span class="s4">'beta'</span><span class="s3">, </span><span class="s4">'b'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'rc'</span><span class="s3">, </span><span class="s4">'c'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'-final'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">(</span><span class="s4">'-pre'</span><span class="s3">, </span><span class="s4">'c'</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">(</span><span class="s4">'-release'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'.release'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'-stable'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">(</span><span class="s4">'+'</span><span class="s3">, </span><span class="s4">'.'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'_'</span><span class="s3">, </span><span class="s4">'.'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">' '</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'.final'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span><span class="s3">,</span>
                       <span class="s1">(</span><span class="s4">'final'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)):</span>
        <span class="s1">rs = rs.replace(orig</span><span class="s3">, </span><span class="s1">repl)</span>

    <span class="s0"># if something ends with dev or pre, we add a 0</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;pre$&quot;</span><span class="s3">, </span><span class="s4">r&quot;pre0&quot;</span><span class="s3">, </span><span class="s1">rs)</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;dev$&quot;</span><span class="s3">, </span><span class="s4">r&quot;dev0&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># if we have something like &quot;b-2&quot; or &quot;a.2&quot; at the end of the</span>
    <span class="s0"># version, that is probably beta, alpha, etc</span>
    <span class="s0"># let's remove the dash or dot</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;([abc]|rc)[\-\.](\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;\1\2&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># 1.0-dev-r371 -&gt; 1.0.dev371</span>
    <span class="s0"># 0.1-dev-r79 -&gt; 0.1.dev79</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;[\-\.](dev)[\-\.]?r?(\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;.\1\2&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># Clean: 2.0.a.3, 2.0.b1, 0.9.0~c1</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;[.~]?([abc])\.?&quot;</span><span class="s3">, </span><span class="s4">r&quot;\1&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># Clean: v0.3, v1.0</span>
    <span class="s3">if </span><span class="s1">rs.startswith(</span><span class="s4">'v'</span><span class="s1">):</span>
        <span class="s1">rs = rs[</span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s0"># Clean leading '0's on numbers.</span>
    <span class="s0">#TODO: unintended side-effect on, e.g., &quot;2003.05.09&quot;</span>
    <span class="s0"># PyPI stats: 77 (~2%) better</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;\b0+(\d+)(?!\d)&quot;</span><span class="s3">, </span><span class="s4">r&quot;\1&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># Clean a/b/c with no version. E.g. &quot;1.0a&quot; -&gt; &quot;1.0a0&quot;. Setuptools infers</span>
    <span class="s0"># zero.</span>
    <span class="s0"># PyPI stats: 245 (7.56%) better</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;(\d+[abc])$&quot;</span><span class="s3">, </span><span class="s4">r&quot;\g&lt;1&gt;0&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># the 'dev-rNNN' tag is a dev tag</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;\.?(dev-r|dev\.r)\.?(\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;.dev\2&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># clean the - when used as a pre delimiter</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;-(a|b|c)(\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;\1\2&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># a terminal &quot;dev&quot; or &quot;devel&quot; can be changed into &quot;.dev0&quot;</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;[\.\-](dev|devel)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;.dev0&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># a terminal &quot;dev&quot; can be changed into &quot;.dev0&quot;</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;(?![\.\-])dev$&quot;</span><span class="s3">, </span><span class="s4">r&quot;.dev0&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># a terminal &quot;final&quot; or &quot;stable&quot; can be removed</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;(final|stable)$&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># The 'r' and the '-' tags are post release tags</span>
    <span class="s0">#   0.4a1.r10       -&gt;  0.4a1.post10</span>
    <span class="s0">#   0.9.33-17222    -&gt;  0.9.33.post17222</span>
    <span class="s0">#   0.9.33-r17222   -&gt;  0.9.33.post17222</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;\.?(r|-|-r)\.?(\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;.post\2&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># Clean 'r' instead of 'dev' usage:</span>
    <span class="s0">#   0.9.33+r17222   -&gt;  0.9.33.dev17222</span>
    <span class="s0">#   1.0dev123       -&gt;  1.0.dev123</span>
    <span class="s0">#   1.0.git123      -&gt;  1.0.dev123</span>
    <span class="s0">#   1.0.bzr123      -&gt;  1.0.dev123</span>
    <span class="s0">#   0.1a0dev.123    -&gt;  0.1a0.dev123</span>
    <span class="s0"># PyPI stats:  ~150 (~4%) better</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;\.?(dev|git|bzr)\.?(\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;.dev\2&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># Clean '.pre' (normalized from '-pre' above) instead of 'c' usage:</span>
    <span class="s0">#   0.2.pre1        -&gt;  0.2c1</span>
    <span class="s0">#   0.2-c1         -&gt;  0.2c1</span>
    <span class="s0">#   1.0preview123   -&gt;  1.0c123</span>
    <span class="s0"># PyPI stats: ~21 (0.62%) better</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;\.?(pre|preview|-c)(\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;c\g&lt;2&gt;&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s0"># Tcl/Tk uses &quot;px&quot; for their post release markers</span>
    <span class="s1">rs = re.sub(</span><span class="s4">r&quot;p(\d+)$&quot;</span><span class="s3">, </span><span class="s4">r&quot;.post\1&quot;</span><span class="s3">, </span><span class="s1">rs)</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">_normalized_key(rs)</span>
    <span class="s3">except </span><span class="s1">UnsupportedVersionError:</span>
        <span class="s1">rs = </span><span class="s3">None</span>
    <span class="s3">return </span><span class="s1">rs</span>

<span class="s0">#</span>
<span class="s0">#   Legacy version processing (distribute-compatible)</span>
<span class="s0">#</span>

<span class="s1">_VERSION_PART = re.compile(</span><span class="s4">r'([a-z]+|\d+|[\.-])'</span><span class="s3">, </span><span class="s1">re.I)</span>
<span class="s1">_VERSION_REPLACE = {</span>
    <span class="s4">'pre'</span><span class="s1">: </span><span class="s4">'c'</span><span class="s3">,</span>
    <span class="s4">'preview'</span><span class="s1">: </span><span class="s4">'c'</span><span class="s3">,</span>
    <span class="s4">'-'</span><span class="s1">: </span><span class="s4">'final-'</span><span class="s3">,</span>
    <span class="s4">'rc'</span><span class="s1">: </span><span class="s4">'c'</span><span class="s3">,</span>
    <span class="s4">'dev'</span><span class="s1">: </span><span class="s4">'@'</span><span class="s3">,</span>
    <span class="s4">''</span><span class="s1">: </span><span class="s3">None,</span>
    <span class="s4">'.'</span><span class="s1">: </span><span class="s3">None,</span>
<span class="s1">}</span>


<span class="s3">def </span><span class="s1">_legacy_key(s):</span>
    <span class="s3">def </span><span class="s1">get_parts(s):</span>
        <span class="s1">result = []</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">_VERSION_PART.split(s.lower()):</span>
            <span class="s1">p = _VERSION_REPLACE.get(p</span><span class="s3">, </span><span class="s1">p)</span>
            <span class="s3">if </span><span class="s1">p:</span>
                <span class="s3">if </span><span class="s4">'0' </span><span class="s1">&lt;= p[:</span><span class="s5">1</span><span class="s1">] &lt;= </span><span class="s4">'9'</span><span class="s1">:</span>
                    <span class="s1">p = p.zfill(</span><span class="s5">8</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">p = </span><span class="s4">'*' </span><span class="s1">+ p</span>
                <span class="s1">result.append(p)</span>
        <span class="s1">result.append(</span><span class="s4">'*final'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s1">result = []</span>
    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">get_parts(s):</span>
        <span class="s3">if </span><span class="s1">p.startswith(</span><span class="s4">'*'</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">p &lt; </span><span class="s4">'*final'</span><span class="s1">:</span>
                <span class="s3">while </span><span class="s1">result </span><span class="s3">and </span><span class="s1">result[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">'*final-'</span><span class="s1">:</span>
                    <span class="s1">result.pop()</span>
            <span class="s3">while </span><span class="s1">result </span><span class="s3">and </span><span class="s1">result[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">'00000000'</span><span class="s1">:</span>
                <span class="s1">result.pop()</span>
        <span class="s1">result.append(p)</span>
    <span class="s3">return </span><span class="s1">tuple(result)</span>


<span class="s3">class </span><span class="s1">LegacyVersion(Version):</span>
    <span class="s3">def </span><span class="s1">parse(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">return </span><span class="s1">_legacy_key(s)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_prerelease(self):</span>
        <span class="s1">result = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self._parts:</span>
            <span class="s3">if </span><span class="s1">(isinstance(x</span><span class="s3">, </span><span class="s1">string_types) </span><span class="s3">and </span><span class="s1">x.startswith(</span><span class="s4">'*'</span><span class="s1">) </span><span class="s3">and</span>
                <span class="s1">x &lt; </span><span class="s4">'*final'</span><span class="s1">):</span>
                <span class="s1">result = </span><span class="s3">True</span>
                <span class="s3">break</span>
        <span class="s3">return </span><span class="s1">result</span>


<span class="s3">class </span><span class="s1">LegacyMatcher(Matcher):</span>
    <span class="s1">version_class = LegacyVersion</span>

    <span class="s1">_operators = dict(Matcher._operators)</span>
    <span class="s1">_operators[</span><span class="s4">'~='</span><span class="s1">] = </span><span class="s4">'_match_compatible'</span>

    <span class="s1">numeric_re = re.compile(</span><span class="s4">r'^(\d+(\.\d+)*)'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_match_compatible(self</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">prefix):</span>
        <span class="s3">if </span><span class="s1">version &lt; constraint:</span>
            <span class="s3">return False</span>
        <span class="s1">m = self.numeric_re.match(str(constraint))</span>
        <span class="s3">if not </span><span class="s1">m:</span>
            <span class="s1">logger.warning(</span><span class="s4">'Cannot compute compatible match for version %s '</span>
                           <span class="s4">' and constraint %s'</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">constraint)</span>
            <span class="s3">return True</span>
        <span class="s1">s = m.groups()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s4">'.' </span><span class="s3">in </span><span class="s1">s:</span>
            <span class="s1">s = s.rsplit(</span><span class="s4">'.'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">_match_prefix(version</span><span class="s3">, </span><span class="s1">s)</span>

<span class="s0">#</span>
<span class="s0">#   Semantic versioning</span>
<span class="s0">#</span>

<span class="s1">_SEMVER_RE = re.compile(</span><span class="s4">r'^(\d+)\.(\d+)\.(\d+)'</span>
                        <span class="s4">r'(-[a-z0-9]+(\.[a-z0-9-]+)*)?'</span>
                        <span class="s4">r'(\+[a-z0-9]+(\.[a-z0-9-]+)*)?$'</span><span class="s3">, </span><span class="s1">re.I)</span>


<span class="s3">def </span><span class="s1">is_semver(s):</span>
    <span class="s3">return </span><span class="s1">_SEMVER_RE.match(s)</span>


<span class="s3">def </span><span class="s1">_semantic_key(s):</span>
    <span class="s3">def </span><span class="s1">make_tuple(s</span><span class="s3">, </span><span class="s1">absent):</span>
        <span class="s3">if </span><span class="s1">s </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">result = (absent</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">parts = s[</span><span class="s5">1</span><span class="s1">:].split(</span><span class="s4">'.'</span><span class="s1">)</span>
            <span class="s0"># We can't compare ints and strings on Python 3, so fudge it</span>
            <span class="s0"># by zero-filling numeric values so simulate a numeric comparison</span>
            <span class="s1">result = tuple([p.zfill(</span><span class="s5">8</span><span class="s1">) </span><span class="s3">if </span><span class="s1">p.isdigit() </span><span class="s3">else </span><span class="s1">p </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">parts])</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s1">m = is_semver(s)</span>
    <span class="s3">if not </span><span class="s1">m:</span>
        <span class="s3">raise </span><span class="s1">UnsupportedVersionError(s)</span>
    <span class="s1">groups = m.groups()</span>
    <span class="s1">major</span><span class="s3">, </span><span class="s1">minor</span><span class="s3">, </span><span class="s1">patch = [int(i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">groups[:</span><span class="s5">3</span><span class="s1">]]</span>
    <span class="s0"># choose the '|' and '*' so that versions sort correctly</span>
    <span class="s1">pre</span><span class="s3">, </span><span class="s1">build = make_tuple(groups[</span><span class="s5">3</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'|'</span><span class="s1">)</span><span class="s3">, </span><span class="s1">make_tuple(groups[</span><span class="s5">5</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'*'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">(major</span><span class="s3">, </span><span class="s1">minor</span><span class="s3">, </span><span class="s1">patch)</span><span class="s3">, </span><span class="s1">pre</span><span class="s3">, </span><span class="s1">build</span>


<span class="s3">class </span><span class="s1">SemanticVersion(Version):</span>
    <span class="s3">def </span><span class="s1">parse(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">return </span><span class="s1">_semantic_key(s)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_prerelease(self):</span>
        <span class="s3">return </span><span class="s1">self._parts[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] != </span><span class="s4">'|'</span>


<span class="s3">class </span><span class="s1">SemanticMatcher(Matcher):</span>
    <span class="s1">version_class = SemanticVersion</span>


<span class="s3">class </span><span class="s1">VersionScheme(object):</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">matcher</span><span class="s3">, </span><span class="s1">suggester=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.key = key</span>
        <span class="s1">self.matcher = matcher</span>
        <span class="s1">self.suggester = suggester</span>

    <span class="s3">def </span><span class="s1">is_valid_version(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.matcher.version_class(s)</span>
            <span class="s1">result = </span><span class="s3">True</span>
        <span class="s3">except </span><span class="s1">UnsupportedVersionError:</span>
            <span class="s1">result = </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">is_valid_matcher(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self.matcher(s)</span>
            <span class="s1">result = </span><span class="s3">True</span>
        <span class="s3">except </span><span class="s1">UnsupportedVersionError:</span>
            <span class="s1">result = </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">is_valid_constraint_list(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s2">&quot;&quot;&quot; 
        Used for processing some metadata fields 
        &quot;&quot;&quot;</span>
        <span class="s0"># See issue #140. Be tolerant of a single trailing comma.</span>
        <span class="s3">if </span><span class="s1">s.endswith(</span><span class="s4">','</span><span class="s1">):</span>
            <span class="s1">s = s[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">self.is_valid_matcher(</span><span class="s4">'dummy_name (%s)' </span><span class="s1">% s)</span>

    <span class="s3">def </span><span class="s1">suggest(self</span><span class="s3">, </span><span class="s1">s):</span>
        <span class="s3">if </span><span class="s1">self.suggester </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">result = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">result = self.suggester(s)</span>
        <span class="s3">return </span><span class="s1">result</span>

<span class="s1">_SCHEMES = {</span>
    <span class="s4">'normalized'</span><span class="s1">: VersionScheme(_normalized_key</span><span class="s3">, </span><span class="s1">NormalizedMatcher</span><span class="s3">,</span>
                                <span class="s1">_suggest_normalized_version)</span><span class="s3">,</span>
    <span class="s4">'legacy'</span><span class="s1">: VersionScheme(_legacy_key</span><span class="s3">, </span><span class="s1">LegacyMatcher</span><span class="s3">, lambda </span><span class="s1">self</span><span class="s3">, </span><span class="s1">s: s)</span><span class="s3">,</span>
    <span class="s4">'semantic'</span><span class="s1">: VersionScheme(_semantic_key</span><span class="s3">, </span><span class="s1">SemanticMatcher</span><span class="s3">,</span>
                              <span class="s1">_suggest_semantic_version)</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">_SCHEMES[</span><span class="s4">'default'</span><span class="s1">] = _SCHEMES[</span><span class="s4">'normalized'</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">get_scheme(name):</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">_SCHEMES:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'unknown scheme name: %r' </span><span class="s1">% name)</span>
    <span class="s3">return </span><span class="s1">_SCHEMES[name]</span>
</pre>
</body>
</html>