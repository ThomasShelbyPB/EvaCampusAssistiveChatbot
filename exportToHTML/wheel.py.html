<html>
<head>
<title>wheel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wheel.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2013-2020 Vinay Sajip.</span>
<span class="s0"># Licensed to the Python Software Foundation under a contributor agreement.</span>
<span class="s0"># See LICENSE.txt and CONTRIBUTORS.txt.</span>
<span class="s0">#</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">unicode_literals</span>

<span class="s2">import </span><span class="s1">base64</span>
<span class="s2">import </span><span class="s1">codecs</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">email </span><span class="s2">import </span><span class="s1">message_from_file</span>
<span class="s2">import </span><span class="s1">hashlib</span>
<span class="s2">import </span><span class="s1">imp</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">posixpath</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">tempfile</span>
<span class="s2">import </span><span class="s1">zipfile</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">__version__</span><span class="s2">, </span><span class="s1">DistlibException</span>
<span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">sysconfig</span><span class="s2">, </span><span class="s1">ZipFile</span><span class="s2">, </span><span class="s1">fsdecode</span><span class="s2">, </span><span class="s1">text_type</span><span class="s2">, </span><span class="s1">filter</span>
<span class="s2">from </span><span class="s1">.database </span><span class="s2">import </span><span class="s1">InstalledDistribution</span>
<span class="s2">from </span><span class="s1">.metadata </span><span class="s2">import </span><span class="s1">(Metadata</span><span class="s2">, </span><span class="s1">METADATA_FILENAME</span><span class="s2">, </span><span class="s1">WHEEL_METADATA_FILENAME</span><span class="s2">,</span>
                       <span class="s1">LEGACY_METADATA_FILENAME)</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">(FileOperator</span><span class="s2">, </span><span class="s1">convert_path</span><span class="s2">, </span><span class="s1">CSVReader</span><span class="s2">, </span><span class="s1">CSVWriter</span><span class="s2">, </span><span class="s1">Cache</span><span class="s2">,</span>
                   <span class="s1">cached_property</span><span class="s2">, </span><span class="s1">get_cache_base</span><span class="s2">, </span><span class="s1">read_exports</span><span class="s2">, </span><span class="s1">tempdir</span><span class="s2">,</span>
                   <span class="s1">get_platform)</span>
<span class="s2">from </span><span class="s1">.version </span><span class="s2">import </span><span class="s1">NormalizedVersion</span><span class="s2">, </span><span class="s1">UnsupportedVersionError</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s1">cache = </span><span class="s2">None    </span><span class="s0"># created when needed</span>

<span class="s2">if </span><span class="s1">hasattr(sys</span><span class="s2">, </span><span class="s3">'pypy_version_info'</span><span class="s1">):  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">IMP_PREFIX = </span><span class="s3">'pp'</span>
<span class="s2">elif </span><span class="s1">sys.platform.startswith(</span><span class="s3">'java'</span><span class="s1">):  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">IMP_PREFIX = </span><span class="s3">'jy'</span>
<span class="s2">elif </span><span class="s1">sys.platform == </span><span class="s3">'cli'</span><span class="s1">:  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">IMP_PREFIX = </span><span class="s3">'ip'</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">IMP_PREFIX = </span><span class="s3">'cp'</span>

<span class="s1">VER_SUFFIX = sysconfig.get_config_var(</span><span class="s3">'py_version_nodot'</span><span class="s1">)</span>
<span class="s2">if not </span><span class="s1">VER_SUFFIX:   </span><span class="s0"># pragma: no cover</span>
    <span class="s1">VER_SUFFIX = </span><span class="s3">'%s%s' </span><span class="s1">% sys.version_info[:</span><span class="s4">2</span><span class="s1">]</span>
<span class="s1">PYVER = </span><span class="s3">'py' </span><span class="s1">+ VER_SUFFIX</span>
<span class="s1">IMPVER = IMP_PREFIX + VER_SUFFIX</span>

<span class="s1">ARCH = get_platform().replace(</span><span class="s3">'-'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">).replace(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span>

<span class="s1">ABI = sysconfig.get_config_var(</span><span class="s3">'SOABI'</span><span class="s1">)</span>
<span class="s2">if </span><span class="s1">ABI </span><span class="s2">and </span><span class="s1">ABI.startswith(</span><span class="s3">'cpython-'</span><span class="s1">):</span>
    <span class="s1">ABI = ABI.replace(</span><span class="s3">'cpython-'</span><span class="s2">, </span><span class="s3">'cp'</span><span class="s1">).split(</span><span class="s3">'-'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">def </span><span class="s1">_derive_abi():</span>
        <span class="s1">parts = [</span><span class="s3">'cp'</span><span class="s2">, </span><span class="s1">VER_SUFFIX]</span>
        <span class="s2">if </span><span class="s1">sysconfig.get_config_var(</span><span class="s3">'Py_DEBUG'</span><span class="s1">):</span>
            <span class="s1">parts.append(</span><span class="s3">'d'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">sysconfig.get_config_var(</span><span class="s3">'WITH_PYMALLOC'</span><span class="s1">):</span>
            <span class="s1">parts.append(</span><span class="s3">'m'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">sysconfig.get_config_var(</span><span class="s3">'Py_UNICODE_SIZE'</span><span class="s1">) == </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s1">parts.append(</span><span class="s3">'u'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">''</span><span class="s1">.join(parts)</span>
    <span class="s1">ABI = _derive_abi()</span>
    <span class="s2">del </span><span class="s1">_derive_abi</span>

<span class="s1">FILENAME_RE = re.compile(</span><span class="s3">r''' 
(?P&lt;nm&gt;[^-]+) 
-(?P&lt;vn&gt;\d+[^-]*) 
(-(?P&lt;bn&gt;\d+[^-]*))? 
-(?P&lt;py&gt;\w+\d+(\.\w+\d+)*) 
-(?P&lt;bi&gt;\w+) 
-(?P&lt;ar&gt;\w+(\.\w+)*) 
\.whl$ 
'''</span><span class="s2">, </span><span class="s1">re.IGNORECASE | re.VERBOSE)</span>

<span class="s1">NAME_VERSION_RE = re.compile(</span><span class="s3">r''' 
(?P&lt;nm&gt;[^-]+) 
-(?P&lt;vn&gt;\d+[^-]*) 
(-(?P&lt;bn&gt;\d+[^-]*))?$ 
'''</span><span class="s2">, </span><span class="s1">re.IGNORECASE | re.VERBOSE)</span>

<span class="s1">SHEBANG_RE = re.compile(</span><span class="s5">br'\s*#![^\r\n]*'</span><span class="s1">)</span>
<span class="s1">SHEBANG_DETAIL_RE = re.compile(</span><span class="s5">br'^(\s*#!(&quot;[^&quot;]+&quot;|\S+))\s+(.*)$'</span><span class="s1">)</span>
<span class="s1">SHEBANG_PYTHON = </span><span class="s5">b'#!python'</span>
<span class="s1">SHEBANG_PYTHONW = </span><span class="s5">b'#!pythonw'</span>

<span class="s2">if </span><span class="s1">os.sep == </span><span class="s3">'/'</span><span class="s1">:</span>
    <span class="s1">to_posix = </span><span class="s2">lambda </span><span class="s1">o: o</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">to_posix = </span><span class="s2">lambda </span><span class="s1">o: o.replace(os.sep</span><span class="s2">, </span><span class="s3">'/'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Mounter(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.impure_wheels = {}</span>
        <span class="s1">self.libs = {}</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">pathname</span><span class="s2">, </span><span class="s1">extensions):</span>
        <span class="s1">self.impure_wheels[pathname] = extensions</span>
        <span class="s1">self.libs.update(extensions)</span>

    <span class="s2">def </span><span class="s1">remove(self</span><span class="s2">, </span><span class="s1">pathname):</span>
        <span class="s1">extensions = self.impure_wheels.pop(pathname)</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">extensions:</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.libs:</span>
                <span class="s2">del </span><span class="s1">self.libs[k]</span>

    <span class="s2">def </span><span class="s1">find_module(self</span><span class="s2">, </span><span class="s1">fullname</span><span class="s2">, </span><span class="s1">path=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">fullname </span><span class="s2">in </span><span class="s1">self.libs:</span>
            <span class="s1">result = self</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">load_module(self</span><span class="s2">, </span><span class="s1">fullname):</span>
        <span class="s2">if </span><span class="s1">fullname </span><span class="s2">in </span><span class="s1">sys.modules:</span>
            <span class="s1">result = sys.modules[fullname]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">fullname </span><span class="s2">not in </span><span class="s1">self.libs:</span>
                <span class="s2">raise </span><span class="s1">ImportError(</span><span class="s3">'unable to find extension for %s' </span><span class="s1">% fullname)</span>
            <span class="s1">result = imp.load_dynamic(fullname</span><span class="s2">, </span><span class="s1">self.libs[fullname])</span>
            <span class="s1">result.__loader__ = self</span>
            <span class="s1">parts = fullname.rsplit(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(parts) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">result.__package__ = parts[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">result</span>

<span class="s1">_hook = Mounter()</span>


<span class="s2">class </span><span class="s1">Wheel(object):</span>
    <span class="s6">&quot;&quot;&quot; 
    Class to build and install from Wheel files (PEP 427). 
    &quot;&quot;&quot;</span>

    <span class="s1">wheel_version = (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">hash_kind = </span><span class="s3">'sha256'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">filename=</span><span class="s2">None, </span><span class="s1">sign=</span><span class="s2">False, </span><span class="s1">verify=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Initialise an instance using a (valid) filename. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.sign = sign</span>
        <span class="s1">self.should_verify = verify</span>
        <span class="s1">self.buildver = </span><span class="s3">''</span>
        <span class="s1">self.pyver = [PYVER]</span>
        <span class="s1">self.abi = [</span><span class="s3">'none'</span><span class="s1">]</span>
        <span class="s1">self.arch = [</span><span class="s3">'any'</span><span class="s1">]</span>
        <span class="s1">self.dirname = os.getcwd()</span>
        <span class="s2">if </span><span class="s1">filename </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.name = </span><span class="s3">'dummy'</span>
            <span class="s1">self.version = </span><span class="s3">'0.1'</span>
            <span class="s1">self._filename = self.filename</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">m = NAME_VERSION_RE.match(filename)</span>
            <span class="s2">if </span><span class="s1">m:</span>
                <span class="s1">info = m.groupdict(</span><span class="s3">''</span><span class="s1">)</span>
                <span class="s1">self.name = info[</span><span class="s3">'nm'</span><span class="s1">]</span>
                <span class="s0"># Reinstate the local version separator</span>
                <span class="s1">self.version = info[</span><span class="s3">'vn'</span><span class="s1">].replace(</span><span class="s3">'_'</span><span class="s2">, </span><span class="s3">'-'</span><span class="s1">)</span>
                <span class="s1">self.buildver = info[</span><span class="s3">'bn'</span><span class="s1">]</span>
                <span class="s1">self._filename = self.filename</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dirname</span><span class="s2">, </span><span class="s1">filename = os.path.split(filename)</span>
                <span class="s1">m = FILENAME_RE.match(filename)</span>
                <span class="s2">if not </span><span class="s1">m:</span>
                    <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'Invalid name or '</span>
                                           <span class="s3">'filename: %r' </span><span class="s1">% filename)</span>
                <span class="s2">if </span><span class="s1">dirname:</span>
                    <span class="s1">self.dirname = os.path.abspath(dirname)</span>
                <span class="s1">self._filename = filename</span>
                <span class="s1">info = m.groupdict(</span><span class="s3">''</span><span class="s1">)</span>
                <span class="s1">self.name = info[</span><span class="s3">'nm'</span><span class="s1">]</span>
                <span class="s1">self.version = info[</span><span class="s3">'vn'</span><span class="s1">]</span>
                <span class="s1">self.buildver = info[</span><span class="s3">'bn'</span><span class="s1">]</span>
                <span class="s1">self.pyver = info[</span><span class="s3">'py'</span><span class="s1">].split(</span><span class="s3">'.'</span><span class="s1">)</span>
                <span class="s1">self.abi = info[</span><span class="s3">'bi'</span><span class="s1">].split(</span><span class="s3">'.'</span><span class="s1">)</span>
                <span class="s1">self.arch = info[</span><span class="s3">'ar'</span><span class="s1">].split(</span><span class="s3">'.'</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">filename(self):</span>
        <span class="s6">&quot;&quot;&quot; 
        Build and return a filename from the various components. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.buildver:</span>
            <span class="s1">buildver = </span><span class="s3">'-' </span><span class="s1">+ self.buildver</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">buildver = </span><span class="s3">''</span>
        <span class="s1">pyver = </span><span class="s3">'.'</span><span class="s1">.join(self.pyver)</span>
        <span class="s1">abi = </span><span class="s3">'.'</span><span class="s1">.join(self.abi)</span>
        <span class="s1">arch = </span><span class="s3">'.'</span><span class="s1">.join(self.arch)</span>
        <span class="s0"># replace - with _ as a local version separator</span>
        <span class="s1">version = self.version.replace(</span><span class="s3">'-'</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">'%s-%s%s-%s-%s-%s.whl' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">version</span><span class="s2">, </span><span class="s1">buildver</span><span class="s2">,</span>
                                         <span class="s1">pyver</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">, </span><span class="s1">arch)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">exists(self):</span>
        <span class="s1">path = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s2">return </span><span class="s1">os.path.isfile(path)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">tags(self):</span>
        <span class="s2">for </span><span class="s1">pyver </span><span class="s2">in </span><span class="s1">self.pyver:</span>
            <span class="s2">for </span><span class="s1">abi </span><span class="s2">in </span><span class="s1">self.abi:</span>
                <span class="s2">for </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">self.arch:</span>
                    <span class="s2">yield </span><span class="s1">pyver</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">, </span><span class="s1">arch</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">metadata(self):</span>
        <span class="s1">pathname = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s1">name_ver = </span><span class="s3">'%s-%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.version)</span>
        <span class="s1">info_dir = </span><span class="s3">'%s.dist-info' </span><span class="s1">% name_ver</span>
        <span class="s1">wrapper = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">ZipFile(pathname</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">zf:</span>
            <span class="s1">wheel_metadata = self.get_wheel_metadata(zf)</span>
            <span class="s1">wv = wheel_metadata[</span><span class="s3">'Wheel-Version'</span><span class="s1">].split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">file_version = tuple([int(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">wv])</span>
            <span class="s0"># if file_version &lt; (1, 1):</span>
                <span class="s0"># fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME,</span>
                       <span class="s0"># LEGACY_METADATA_FILENAME]</span>
            <span class="s0"># else:</span>
                <span class="s0"># fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME]</span>
            <span class="s1">fns = [WHEEL_METADATA_FILENAME</span><span class="s2">, </span><span class="s1">LEGACY_METADATA_FILENAME]</span>
            <span class="s1">result = </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">fns:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">metadata_filename = posixpath.join(info_dir</span><span class="s2">, </span><span class="s1">fn)</span>
                    <span class="s2">with </span><span class="s1">zf.open(metadata_filename) </span><span class="s2">as </span><span class="s1">bf:</span>
                        <span class="s1">wf = wrapper(bf)</span>
                        <span class="s1">result = Metadata(fileobj=wf)</span>
                        <span class="s2">if </span><span class="s1">result:</span>
                            <span class="s2">break</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s2">pass</span>
            <span class="s2">if not </span><span class="s1">result:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Invalid wheel, because metadata is '</span>
                                 <span class="s3">'missing: looked in %s' </span><span class="s1">% </span><span class="s3">', '</span><span class="s1">.join(fns))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">get_wheel_metadata(self</span><span class="s2">, </span><span class="s1">zf):</span>
        <span class="s1">name_ver = </span><span class="s3">'%s-%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.version)</span>
        <span class="s1">info_dir = </span><span class="s3">'%s.dist-info' </span><span class="s1">% name_ver</span>
        <span class="s1">metadata_filename = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'WHEEL'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">zf.open(metadata_filename) </span><span class="s2">as </span><span class="s1">bf:</span>
            <span class="s1">wf = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)(bf)</span>
            <span class="s1">message = message_from_file(wf)</span>
        <span class="s2">return </span><span class="s1">dict(message)</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">info(self):</span>
        <span class="s1">pathname = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s2">with </span><span class="s1">ZipFile(pathname</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">zf:</span>
            <span class="s1">result = self.get_wheel_metadata(zf)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">process_shebang(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">m = SHEBANG_RE.match(data)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">end = m.end()</span>
            <span class="s1">shebang</span><span class="s2">, </span><span class="s1">data_after_shebang = data[:end]</span><span class="s2">, </span><span class="s1">data[end:]</span>
            <span class="s0"># Preserve any arguments after the interpreter</span>
            <span class="s2">if </span><span class="s5">b'pythonw' </span><span class="s2">in </span><span class="s1">shebang.lower():</span>
                <span class="s1">shebang_python = SHEBANG_PYTHONW</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">shebang_python = SHEBANG_PYTHON</span>
            <span class="s1">m = SHEBANG_DETAIL_RE.match(shebang)</span>
            <span class="s2">if </span><span class="s1">m:</span>
                <span class="s1">args = </span><span class="s5">b' ' </span><span class="s1">+ m.groups()[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">args = </span><span class="s5">b''</span>
            <span class="s1">shebang = shebang_python + args</span>
            <span class="s1">data = shebang + data_after_shebang</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cr = data.find(</span><span class="s5">b'</span><span class="s2">\r</span><span class="s5">'</span><span class="s1">)</span>
            <span class="s1">lf = data.find(</span><span class="s5">b'</span><span class="s2">\n</span><span class="s5">'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">cr &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">cr &gt; lf:</span>
                <span class="s1">term = </span><span class="s5">b'</span><span class="s2">\n</span><span class="s5">'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">data[cr:cr + </span><span class="s4">2</span><span class="s1">] == </span><span class="s5">b'</span><span class="s2">\r\n</span><span class="s5">'</span><span class="s1">:</span>
                    <span class="s1">term = </span><span class="s5">b'</span><span class="s2">\r\n</span><span class="s5">'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">term = </span><span class="s5">b'</span><span class="s2">\r</span><span class="s5">'</span>
            <span class="s1">data = SHEBANG_PYTHON + term + data</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">get_hash(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">hash_kind=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">hash_kind </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">hash_kind = self.hash_kind</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">hasher = getattr(hashlib</span><span class="s2">, </span><span class="s1">hash_kind)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'Unsupported hash algorithm: %r' </span><span class="s1">% hash_kind)</span>
        <span class="s1">result = hasher(data).digest()</span>
        <span class="s1">result = base64.urlsafe_b64encode(result).rstrip(</span><span class="s5">b'='</span><span class="s1">).decode(</span><span class="s3">'ascii'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">hash_kind</span><span class="s2">, </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">write_record(self</span><span class="s2">, </span><span class="s1">records</span><span class="s2">, </span><span class="s1">record_path</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s1">records = list(records) </span><span class="s0"># make a copy, as mutated</span>
        <span class="s1">p = to_posix(os.path.relpath(record_path</span><span class="s2">, </span><span class="s1">base))</span>
        <span class="s1">records.append((p</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s3">''</span><span class="s1">))</span>
        <span class="s2">with </span><span class="s1">CSVWriter(record_path) </span><span class="s2">as </span><span class="s1">writer:</span>
            <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">records:</span>
                <span class="s1">writer.writerow(row)</span>

    <span class="s2">def </span><span class="s1">write_records(self</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">libdir</span><span class="s2">, </span><span class="s1">archive_paths):</span>
        <span class="s1">records = []</span>
        <span class="s1">distinfo</span><span class="s2">, </span><span class="s1">info_dir = info</span>
        <span class="s1">hasher = getattr(hashlib</span><span class="s2">, </span><span class="s1">self.hash_kind)</span>
        <span class="s2">for </span><span class="s1">ap</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">archive_paths:</span>
            <span class="s2">with </span><span class="s1">open(p</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">data = f.read()</span>
            <span class="s1">digest = </span><span class="s3">'%s=%s' </span><span class="s1">% self.get_hash(data)</span>
            <span class="s1">size = os.path.getsize(p)</span>
            <span class="s1">records.append((ap</span><span class="s2">, </span><span class="s1">digest</span><span class="s2">, </span><span class="s1">size))</span>

        <span class="s1">p = os.path.join(distinfo</span><span class="s2">, </span><span class="s3">'RECORD'</span><span class="s1">)</span>
        <span class="s1">self.write_record(records</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">libdir)</span>
        <span class="s1">ap = to_posix(os.path.join(info_dir</span><span class="s2">, </span><span class="s3">'RECORD'</span><span class="s1">))</span>
        <span class="s1">archive_paths.append((ap</span><span class="s2">, </span><span class="s1">p))</span>

    <span class="s2">def </span><span class="s1">build_zip(self</span><span class="s2">, </span><span class="s1">pathname</span><span class="s2">, </span><span class="s1">archive_paths):</span>
        <span class="s2">with </span><span class="s1">ZipFile(pathname</span><span class="s2">, </span><span class="s3">'w'</span><span class="s2">, </span><span class="s1">zipfile.ZIP_DEFLATED) </span><span class="s2">as </span><span class="s1">zf:</span>
            <span class="s2">for </span><span class="s1">ap</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">archive_paths:</span>
                <span class="s1">logger.debug(</span><span class="s3">'Wrote %s to %s in wheel'</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">ap)</span>
                <span class="s1">zf.write(p</span><span class="s2">, </span><span class="s1">ap)</span>

    <span class="s2">def </span><span class="s1">build(self</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">tags=</span><span class="s2">None, </span><span class="s1">wheel_version=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Build a wheel from files in specified paths, and use any specified tags 
        when determining the name of the wheel. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">tags </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">tags = {}</span>

        <span class="s1">libkey = list(filter(</span><span class="s2">lambda </span><span class="s1">o: o </span><span class="s2">in </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'purelib'</span><span class="s2">, </span><span class="s3">'platlib'</span><span class="s1">)))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">libkey == </span><span class="s3">'platlib'</span><span class="s1">:</span>
            <span class="s1">is_pure = </span><span class="s3">'false'</span>
            <span class="s1">default_pyver = [IMPVER]</span>
            <span class="s1">default_abi = [ABI]</span>
            <span class="s1">default_arch = [ARCH]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">is_pure = </span><span class="s3">'true'</span>
            <span class="s1">default_pyver = [PYVER]</span>
            <span class="s1">default_abi = [</span><span class="s3">'none'</span><span class="s1">]</span>
            <span class="s1">default_arch = [</span><span class="s3">'any'</span><span class="s1">]</span>

        <span class="s1">self.pyver = tags.get(</span><span class="s3">'pyver'</span><span class="s2">, </span><span class="s1">default_pyver)</span>
        <span class="s1">self.abi = tags.get(</span><span class="s3">'abi'</span><span class="s2">, </span><span class="s1">default_abi)</span>
        <span class="s1">self.arch = tags.get(</span><span class="s3">'arch'</span><span class="s2">, </span><span class="s1">default_arch)</span>

        <span class="s1">libdir = paths[libkey]</span>

        <span class="s1">name_ver = </span><span class="s3">'%s-%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.version)</span>
        <span class="s1">data_dir = </span><span class="s3">'%s.data' </span><span class="s1">% name_ver</span>
        <span class="s1">info_dir = </span><span class="s3">'%s.dist-info' </span><span class="s1">% name_ver</span>

        <span class="s1">archive_paths = []</span>

        <span class="s0"># First, stuff which is not in site-packages</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'data'</span><span class="s2">, </span><span class="s3">'headers'</span><span class="s2">, </span><span class="s3">'scripts'</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">paths:</span>
                <span class="s2">continue</span>
            <span class="s1">path = paths[key]</span>
            <span class="s2">if </span><span class="s1">os.path.isdir(path):</span>
                <span class="s2">for </span><span class="s1">root</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os.walk(path):</span>
                    <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">files:</span>
                        <span class="s1">p = fsdecode(os.path.join(root</span><span class="s2">, </span><span class="s1">fn))</span>
                        <span class="s1">rp = os.path.relpath(p</span><span class="s2">, </span><span class="s1">path)</span>
                        <span class="s1">ap = to_posix(os.path.join(data_dir</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">rp))</span>
                        <span class="s1">archive_paths.append((ap</span><span class="s2">, </span><span class="s1">p))</span>
                        <span class="s2">if </span><span class="s1">key == </span><span class="s3">'scripts' </span><span class="s2">and not </span><span class="s1">p.endswith(</span><span class="s3">'.exe'</span><span class="s1">):</span>
                            <span class="s2">with </span><span class="s1">open(p</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                                <span class="s1">data = f.read()</span>
                            <span class="s1">data = self.process_shebang(data)</span>
                            <span class="s2">with </span><span class="s1">open(p</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
                                <span class="s1">f.write(data)</span>

        <span class="s0"># Now, stuff which is in site-packages, other than the</span>
        <span class="s0"># distinfo stuff.</span>
        <span class="s1">path = libdir</span>
        <span class="s1">distinfo = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">root</span><span class="s2">, </span><span class="s1">dirs</span><span class="s2">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os.walk(path):</span>
            <span class="s2">if </span><span class="s1">root == path:</span>
                <span class="s0"># At the top level only, save distinfo for later</span>
                <span class="s0"># and skip it for now</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">dn </span><span class="s2">in </span><span class="s1">enumerate(dirs):</span>
                    <span class="s1">dn = fsdecode(dn)</span>
                    <span class="s2">if </span><span class="s1">dn.endswith(</span><span class="s3">'.dist-info'</span><span class="s1">):</span>
                        <span class="s1">distinfo = os.path.join(root</span><span class="s2">, </span><span class="s1">dn)</span>
                        <span class="s2">del </span><span class="s1">dirs[i]</span>
                        <span class="s2">break</span>
                <span class="s2">assert </span><span class="s1">distinfo</span><span class="s2">, </span><span class="s3">'.dist-info directory expected, not found'</span>

            <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s0"># comment out next suite to leave .pyc files in</span>
                <span class="s2">if </span><span class="s1">fsdecode(fn).endswith((</span><span class="s3">'.pyc'</span><span class="s2">, </span><span class="s3">'.pyo'</span><span class="s1">)):</span>
                    <span class="s2">continue</span>
                <span class="s1">p = os.path.join(root</span><span class="s2">, </span><span class="s1">fn)</span>
                <span class="s1">rp = to_posix(os.path.relpath(p</span><span class="s2">, </span><span class="s1">path))</span>
                <span class="s1">archive_paths.append((rp</span><span class="s2">, </span><span class="s1">p))</span>

        <span class="s0"># Now distinfo. Assumed to be flat, i.e. os.listdir is enough.</span>
        <span class="s1">files = os.listdir(distinfo)</span>
        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">files:</span>
            <span class="s2">if </span><span class="s1">fn </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'RECORD'</span><span class="s2">, </span><span class="s3">'INSTALLER'</span><span class="s2">, </span><span class="s3">'SHARED'</span><span class="s2">, </span><span class="s3">'WHEEL'</span><span class="s1">):</span>
                <span class="s1">p = fsdecode(os.path.join(distinfo</span><span class="s2">, </span><span class="s1">fn))</span>
                <span class="s1">ap = to_posix(os.path.join(info_dir</span><span class="s2">, </span><span class="s1">fn))</span>
                <span class="s1">archive_paths.append((ap</span><span class="s2">, </span><span class="s1">p))</span>

        <span class="s1">wheel_metadata = [</span>
            <span class="s3">'Wheel-Version: %d.%d' </span><span class="s1">% (wheel_version </span><span class="s2">or </span><span class="s1">self.wheel_version)</span><span class="s2">,</span>
            <span class="s3">'Generator: distlib %s' </span><span class="s1">% __version__</span><span class="s2">,</span>
            <span class="s3">'Root-Is-Purelib: %s' </span><span class="s1">% is_pure</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">pyver</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">, </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">self.tags:</span>
            <span class="s1">wheel_metadata.append(</span><span class="s3">'Tag: %s-%s-%s' </span><span class="s1">% (pyver</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">, </span><span class="s1">arch))</span>
        <span class="s1">p = os.path.join(distinfo</span><span class="s2">, </span><span class="s3">'WHEEL'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">open(p</span><span class="s2">, </span><span class="s3">'w'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
            <span class="s1">f.write(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(wheel_metadata))</span>
        <span class="s1">ap = to_posix(os.path.join(info_dir</span><span class="s2">, </span><span class="s3">'WHEEL'</span><span class="s1">))</span>
        <span class="s1">archive_paths.append((ap</span><span class="s2">, </span><span class="s1">p))</span>

        <span class="s0"># sort the entries by archive path. Not needed by any spec, but it</span>
        <span class="s0"># keeps the archive listing and RECORD tidier than they would otherwise</span>
        <span class="s0"># be. Use the number of path segments to keep directory entries together,</span>
        <span class="s0"># and keep the dist-info stuff at the end.</span>
        <span class="s2">def </span><span class="s1">sorter(t):</span>
            <span class="s1">ap = t[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">n = ap.count(</span><span class="s3">'/'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s3">'.dist-info' </span><span class="s2">in </span><span class="s1">ap:</span>
                <span class="s1">n += </span><span class="s4">10000</span>
            <span class="s2">return </span><span class="s1">(n</span><span class="s2">, </span><span class="s1">ap)</span>
        <span class="s1">archive_paths = sorted(archive_paths</span><span class="s2">, </span><span class="s1">key=sorter)</span>

        <span class="s0"># Now, at last, RECORD.</span>
        <span class="s0"># Paths in here are archive paths - nothing else makes sense.</span>
        <span class="s1">self.write_records((distinfo</span><span class="s2">, </span><span class="s1">info_dir)</span><span class="s2">, </span><span class="s1">libdir</span><span class="s2">, </span><span class="s1">archive_paths)</span>
        <span class="s0"># Now, ready to build the zip file</span>
        <span class="s1">pathname = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s1">self.build_zip(pathname</span><span class="s2">, </span><span class="s1">archive_paths)</span>
        <span class="s2">return </span><span class="s1">pathname</span>

    <span class="s2">def </span><span class="s1">skip_entry(self</span><span class="s2">, </span><span class="s1">arcname):</span>
        <span class="s6">&quot;&quot;&quot; 
        Determine whether an archive entry should be skipped when verifying 
        or installing. 
        &quot;&quot;&quot;</span>
        <span class="s0"># The signature file won't be in RECORD,</span>
        <span class="s0"># and we  don't currently don't do anything with it</span>
        <span class="s0"># We also skip directories, as they won't be in RECORD</span>
        <span class="s0"># either. See:</span>
        <span class="s0">#</span>
        <span class="s0"># https://github.com/pypa/wheel/issues/294</span>
        <span class="s0"># https://github.com/pypa/wheel/issues/287</span>
        <span class="s0"># https://github.com/pypa/wheel/pull/289</span>
        <span class="s0">#</span>
        <span class="s2">return </span><span class="s1">arcname.endswith((</span><span class="s3">'/'</span><span class="s2">, </span><span class="s3">'/RECORD.jws'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">install(self</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">maker</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s6">&quot;&quot;&quot; 
        Install a wheel to the specified paths. If kwarg ``warner`` is 
        specified, it should be a callable, which will be called with two 
        tuples indicating the wheel version of this software and the wheel 
        version in the file, if there is a discrepancy in the versions. 
        This can be used to issue any warnings to raise any exceptions. 
        If kwarg ``lib_only`` is True, only the purelib/platlib files are 
        installed, and the headers, scripts, data and dist-info metadata are 
        not written. If kwarg ``bytecode_hashed_invalidation`` is True, written 
        bytecode will try to use file-hash based invalidation (PEP-552) on 
        supported interpreter versions (CPython 2.7+). 
 
        The return value is a :class:`InstalledDistribution` instance unless 
        ``options.lib_only`` is True, in which case the return value is ``None``. 
        &quot;&quot;&quot;</span>

        <span class="s1">dry_run = maker.dry_run</span>
        <span class="s1">warner = kwargs.get(</span><span class="s3">'warner'</span><span class="s1">)</span>
        <span class="s1">lib_only = kwargs.get(</span><span class="s3">'lib_only'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">bc_hashed_invalidation = kwargs.get(</span><span class="s3">'bytecode_hashed_invalidation'</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s1">pathname = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s1">name_ver = </span><span class="s3">'%s-%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.version)</span>
        <span class="s1">data_dir = </span><span class="s3">'%s.data' </span><span class="s1">% name_ver</span>
        <span class="s1">info_dir = </span><span class="s3">'%s.dist-info' </span><span class="s1">% name_ver</span>

        <span class="s1">metadata_name = posixpath.join(info_dir</span><span class="s2">, </span><span class="s1">LEGACY_METADATA_FILENAME)</span>
        <span class="s1">wheel_metadata_name = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'WHEEL'</span><span class="s1">)</span>
        <span class="s1">record_name = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'RECORD'</span><span class="s1">)</span>

        <span class="s1">wrapper = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">ZipFile(pathname</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">zf:</span>
            <span class="s2">with </span><span class="s1">zf.open(wheel_metadata_name) </span><span class="s2">as </span><span class="s1">bwf:</span>
                <span class="s1">wf = wrapper(bwf)</span>
                <span class="s1">message = message_from_file(wf)</span>
            <span class="s1">wv = message[</span><span class="s3">'Wheel-Version'</span><span class="s1">].split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">file_version = tuple([int(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">wv])</span>
            <span class="s2">if </span><span class="s1">(file_version != self.wheel_version) </span><span class="s2">and </span><span class="s1">warner:</span>
                <span class="s1">warner(self.wheel_version</span><span class="s2">, </span><span class="s1">file_version)</span>

            <span class="s2">if </span><span class="s1">message[</span><span class="s3">'Root-Is-Purelib'</span><span class="s1">] == </span><span class="s3">'true'</span><span class="s1">:</span>
                <span class="s1">libdir = paths[</span><span class="s3">'purelib'</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">libdir = paths[</span><span class="s3">'platlib'</span><span class="s1">]</span>

            <span class="s1">records = {}</span>
            <span class="s2">with </span><span class="s1">zf.open(record_name) </span><span class="s2">as </span><span class="s1">bf:</span>
                <span class="s2">with </span><span class="s1">CSVReader(stream=bf) </span><span class="s2">as </span><span class="s1">reader:</span>
                    <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">reader:</span>
                        <span class="s1">p = row[</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s1">records[p] = row</span>

            <span class="s1">data_pfx = posixpath.join(data_dir</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">info_pfx = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
            <span class="s1">script_pfx = posixpath.join(data_dir</span><span class="s2">, </span><span class="s3">'scripts'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>

            <span class="s0"># make a new instance rather than a copy of maker's,</span>
            <span class="s0"># as we mutate it</span>
            <span class="s1">fileop = FileOperator(dry_run=dry_run)</span>
            <span class="s1">fileop.record = </span><span class="s2">True    </span><span class="s0"># so we can rollback if needed</span>

            <span class="s1">bc = </span><span class="s2">not </span><span class="s1">sys.dont_write_bytecode    </span><span class="s0"># Double negatives. Lovely!</span>

            <span class="s1">outfiles = []   </span><span class="s0"># for RECORD writing</span>

            <span class="s0"># for script copying/shebang processing</span>
            <span class="s1">workdir = tempfile.mkdtemp()</span>
            <span class="s0"># set target dir later</span>
            <span class="s0"># we default add_launchers to False, as the</span>
            <span class="s0"># Python Launcher should be used instead</span>
            <span class="s1">maker.source_dir = workdir</span>
            <span class="s1">maker.target_dir = </span><span class="s2">None</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">zinfo </span><span class="s2">in </span><span class="s1">zf.infolist():</span>
                    <span class="s1">arcname = zinfo.filename</span>
                    <span class="s2">if </span><span class="s1">isinstance(arcname</span><span class="s2">, </span><span class="s1">text_type):</span>
                        <span class="s1">u_arcname = arcname</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">u_arcname = arcname.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">self.skip_entry(u_arcname):</span>
                        <span class="s2">continue</span>
                    <span class="s1">row = records[u_arcname]</span>
                    <span class="s2">if </span><span class="s1">row[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">and </span><span class="s1">str(zinfo.file_size) != row[</span><span class="s4">2</span><span class="s1">]:</span>
                        <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'size mismatch for '</span>
                                               <span class="s3">'%s' </span><span class="s1">% u_arcname)</span>
                    <span class="s2">if </span><span class="s1">row[</span><span class="s4">1</span><span class="s1">]:</span>
                        <span class="s1">kind</span><span class="s2">, </span><span class="s1">value = row[</span><span class="s4">1</span><span class="s1">].split(</span><span class="s3">'='</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s2">with </span><span class="s1">zf.open(arcname) </span><span class="s2">as </span><span class="s1">bf:</span>
                            <span class="s1">data = bf.read()</span>
                        <span class="s1">_</span><span class="s2">, </span><span class="s1">digest = self.get_hash(data</span><span class="s2">, </span><span class="s1">kind)</span>
                        <span class="s2">if </span><span class="s1">digest != value:</span>
                            <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'digest mismatch for '</span>
                                                   <span class="s3">'%s' </span><span class="s1">% arcname)</span>

                    <span class="s2">if </span><span class="s1">lib_only </span><span class="s2">and </span><span class="s1">u_arcname.startswith((info_pfx</span><span class="s2">, </span><span class="s1">data_pfx)):</span>
                        <span class="s1">logger.debug(</span><span class="s3">'lib_only: skipping %s'</span><span class="s2">, </span><span class="s1">u_arcname)</span>
                        <span class="s2">continue</span>
                    <span class="s1">is_script = (u_arcname.startswith(script_pfx)</span>
                                 <span class="s2">and not </span><span class="s1">u_arcname.endswith(</span><span class="s3">'.exe'</span><span class="s1">))</span>

                    <span class="s2">if </span><span class="s1">u_arcname.startswith(data_pfx):</span>
                        <span class="s1">_</span><span class="s2">, </span><span class="s1">where</span><span class="s2">, </span><span class="s1">rp = u_arcname.split(</span><span class="s3">'/'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
                        <span class="s1">outfile = os.path.join(paths[where]</span><span class="s2">, </span><span class="s1">convert_path(rp))</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s0"># meant for site-packages.</span>
                        <span class="s2">if </span><span class="s1">u_arcname </span><span class="s2">in </span><span class="s1">(wheel_metadata_name</span><span class="s2">, </span><span class="s1">record_name):</span>
                            <span class="s2">continue</span>
                        <span class="s1">outfile = os.path.join(libdir</span><span class="s2">, </span><span class="s1">convert_path(u_arcname))</span>
                    <span class="s2">if not </span><span class="s1">is_script:</span>
                        <span class="s2">with </span><span class="s1">zf.open(arcname) </span><span class="s2">as </span><span class="s1">bf:</span>
                            <span class="s1">fileop.copy_stream(bf</span><span class="s2">, </span><span class="s1">outfile)</span>
                        <span class="s0"># Issue #147: permission bits aren't preserved. Using</span>
                        <span class="s0"># zf.extract(zinfo, libdir) should have worked, but didn't,</span>
                        <span class="s0"># see https://www.thetopsites.net/article/53834422.shtml</span>
                        <span class="s0"># So ... manually preserve permission bits as given in zinfo</span>
                        <span class="s2">if </span><span class="s1">os.name == </span><span class="s3">'posix'</span><span class="s1">:</span>
                            <span class="s0"># just set the normal permission bits</span>
                            <span class="s1">os.chmod(outfile</span><span class="s2">, </span><span class="s1">(zinfo.external_attr &gt;&gt; </span><span class="s4">16</span><span class="s1">) &amp; </span><span class="s4">0x1FF</span><span class="s1">)</span>
                        <span class="s1">outfiles.append(outfile)</span>
                        <span class="s0"># Double check the digest of the written file</span>
                        <span class="s2">if not </span><span class="s1">dry_run </span><span class="s2">and </span><span class="s1">row[</span><span class="s4">1</span><span class="s1">]:</span>
                            <span class="s2">with </span><span class="s1">open(outfile</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">bf:</span>
                                <span class="s1">data = bf.read()</span>
                                <span class="s1">_</span><span class="s2">, </span><span class="s1">newdigest = self.get_hash(data</span><span class="s2">, </span><span class="s1">kind)</span>
                                <span class="s2">if </span><span class="s1">newdigest != digest:</span>
                                    <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'digest mismatch '</span>
                                                           <span class="s3">'on write for '</span>
                                                           <span class="s3">'%s' </span><span class="s1">% outfile)</span>
                        <span class="s2">if </span><span class="s1">bc </span><span class="s2">and </span><span class="s1">outfile.endswith(</span><span class="s3">'.py'</span><span class="s1">):</span>
                            <span class="s2">try</span><span class="s1">:</span>
                                <span class="s1">pyc = fileop.byte_compile(outfile</span><span class="s2">,</span>
                                                          <span class="s1">hashed_invalidation=bc_hashed_invalidation)</span>
                                <span class="s1">outfiles.append(pyc)</span>
                            <span class="s2">except </span><span class="s1">Exception:</span>
                                <span class="s0"># Don't give up if byte-compilation fails,</span>
                                <span class="s0"># but log it and perhaps warn the user</span>
                                <span class="s1">logger.warning(</span><span class="s3">'Byte-compilation failed'</span><span class="s2">,</span>
                                               <span class="s1">exc_info=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">fn = os.path.basename(convert_path(arcname))</span>
                        <span class="s1">workname = os.path.join(workdir</span><span class="s2">, </span><span class="s1">fn)</span>
                        <span class="s2">with </span><span class="s1">zf.open(arcname) </span><span class="s2">as </span><span class="s1">bf:</span>
                            <span class="s1">fileop.copy_stream(bf</span><span class="s2">, </span><span class="s1">workname)</span>

                        <span class="s1">dn</span><span class="s2">, </span><span class="s1">fn = os.path.split(outfile)</span>
                        <span class="s1">maker.target_dir = dn</span>
                        <span class="s1">filenames = maker.make(fn)</span>
                        <span class="s1">fileop.set_executable_mode(filenames)</span>
                        <span class="s1">outfiles.extend(filenames)</span>

                <span class="s2">if </span><span class="s1">lib_only:</span>
                    <span class="s1">logger.debug(</span><span class="s3">'lib_only: returning None'</span><span class="s1">)</span>
                    <span class="s1">dist = </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s0"># Generate scripts</span>

                    <span class="s0"># Try to get pydist.json so we can see if there are</span>
                    <span class="s0"># any commands to generate. If this fails (e.g. because</span>
                    <span class="s0"># of a legacy wheel), log a warning but don't give up.</span>
                    <span class="s1">commands = </span><span class="s2">None</span>
                    <span class="s1">file_version = self.info[</span><span class="s3">'Wheel-Version'</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">file_version == </span><span class="s3">'1.0'</span><span class="s1">:</span>
                        <span class="s0"># Use legacy info</span>
                        <span class="s1">ep = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'entry_points.txt'</span><span class="s1">)</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s2">with </span><span class="s1">zf.open(ep) </span><span class="s2">as </span><span class="s1">bwf:</span>
                                <span class="s1">epdata = read_exports(bwf)</span>
                            <span class="s1">commands = {}</span>
                            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'console'</span><span class="s2">, </span><span class="s3">'gui'</span><span class="s1">):</span>
                                <span class="s1">k = </span><span class="s3">'%s_scripts' </span><span class="s1">% key</span>
                                <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">epdata:</span>
                                    <span class="s1">commands[</span><span class="s3">'wrap_%s' </span><span class="s1">% key] = d = {}</span>
                                    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">epdata[k].values():</span>
                                        <span class="s1">s = </span><span class="s3">'%s:%s' </span><span class="s1">% (v.prefix</span><span class="s2">, </span><span class="s1">v.suffix)</span>
                                        <span class="s2">if </span><span class="s1">v.flags:</span>
                                            <span class="s1">s += </span><span class="s3">' [%s]' </span><span class="s1">% </span><span class="s3">','</span><span class="s1">.join(v.flags)</span>
                                        <span class="s1">d[v.name] = s</span>
                        <span class="s2">except </span><span class="s1">Exception:</span>
                            <span class="s1">logger.warning(</span><span class="s3">'Unable to read legacy script '</span>
                                           <span class="s3">'metadata, so cannot generate '</span>
                                           <span class="s3">'scripts'</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s2">with </span><span class="s1">zf.open(metadata_name) </span><span class="s2">as </span><span class="s1">bwf:</span>
                                <span class="s1">wf = wrapper(bwf)</span>
                                <span class="s1">commands = json.load(wf).get(</span><span class="s3">'extensions'</span><span class="s1">)</span>
                                <span class="s2">if </span><span class="s1">commands:</span>
                                    <span class="s1">commands = commands.get(</span><span class="s3">'python.commands'</span><span class="s1">)</span>
                        <span class="s2">except </span><span class="s1">Exception:</span>
                            <span class="s1">logger.warning(</span><span class="s3">'Unable to read JSON metadata, so '</span>
                                           <span class="s3">'cannot generate scripts'</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">commands:</span>
                        <span class="s1">console_scripts = commands.get(</span><span class="s3">'wrap_console'</span><span class="s2">, </span><span class="s1">{})</span>
                        <span class="s1">gui_scripts = commands.get(</span><span class="s3">'wrap_gui'</span><span class="s2">, </span><span class="s1">{})</span>
                        <span class="s2">if </span><span class="s1">console_scripts </span><span class="s2">or </span><span class="s1">gui_scripts:</span>
                            <span class="s1">script_dir = paths.get(</span><span class="s3">'scripts'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
                            <span class="s2">if not </span><span class="s1">os.path.isdir(script_dir):</span>
                                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Valid script path not '</span>
                                                 <span class="s3">'specified'</span><span class="s1">)</span>
                            <span class="s1">maker.target_dir = script_dir</span>
                            <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">console_scripts.items():</span>
                                <span class="s1">script = </span><span class="s3">'%s = %s' </span><span class="s1">% (k</span><span class="s2">, </span><span class="s1">v)</span>
                                <span class="s1">filenames = maker.make(script)</span>
                                <span class="s1">fileop.set_executable_mode(filenames)</span>

                            <span class="s2">if </span><span class="s1">gui_scripts:</span>
                                <span class="s1">options = {</span><span class="s3">'gui'</span><span class="s1">: </span><span class="s2">True </span><span class="s1">}</span>
                                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">gui_scripts.items():</span>
                                    <span class="s1">script = </span><span class="s3">'%s = %s' </span><span class="s1">% (k</span><span class="s2">, </span><span class="s1">v)</span>
                                    <span class="s1">filenames = maker.make(script</span><span class="s2">, </span><span class="s1">options)</span>
                                    <span class="s1">fileop.set_executable_mode(filenames)</span>

                    <span class="s1">p = os.path.join(libdir</span><span class="s2">, </span><span class="s1">info_dir)</span>
                    <span class="s1">dist = InstalledDistribution(p)</span>

                    <span class="s0"># Write SHARED</span>
                    <span class="s1">paths = dict(paths)     </span><span class="s0"># don't change passed in dict</span>
                    <span class="s2">del </span><span class="s1">paths[</span><span class="s3">'purelib'</span><span class="s1">]</span>
                    <span class="s2">del </span><span class="s1">paths[</span><span class="s3">'platlib'</span><span class="s1">]</span>
                    <span class="s1">paths[</span><span class="s3">'lib'</span><span class="s1">] = libdir</span>
                    <span class="s1">p = dist.write_shared_locations(paths</span><span class="s2">, </span><span class="s1">dry_run)</span>
                    <span class="s2">if </span><span class="s1">p:</span>
                        <span class="s1">outfiles.append(p)</span>

                    <span class="s0"># Write RECORD</span>
                    <span class="s1">dist.write_installed_files(outfiles</span><span class="s2">, </span><span class="s1">paths[</span><span class="s3">'prefix'</span><span class="s1">]</span><span class="s2">,</span>
                                               <span class="s1">dry_run)</span>
                <span class="s2">return </span><span class="s1">dist</span>
            <span class="s2">except </span><span class="s1">Exception:  </span><span class="s0"># pragma: no cover</span>
                <span class="s1">logger.exception(</span><span class="s3">'installation failed.'</span><span class="s1">)</span>
                <span class="s1">fileop.rollback()</span>
                <span class="s2">raise</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">shutil.rmtree(workdir)</span>

    <span class="s2">def </span><span class="s1">_get_dylib_cache(self):</span>
        <span class="s2">global </span><span class="s1">cache</span>
        <span class="s2">if </span><span class="s1">cache </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Use native string to avoid issues on 2.x: see Python #20140.</span>
            <span class="s1">base = os.path.join(get_cache_base()</span><span class="s2">, </span><span class="s1">str(</span><span class="s3">'dylib-cache'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s3">'%s.%s' </span><span class="s1">% sys.version_info[:</span><span class="s4">2</span><span class="s1">])</span>
            <span class="s1">cache = Cache(base)</span>
        <span class="s2">return </span><span class="s1">cache</span>

    <span class="s2">def </span><span class="s1">_get_extensions(self):</span>
        <span class="s1">pathname = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s1">name_ver = </span><span class="s3">'%s-%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.version)</span>
        <span class="s1">info_dir = </span><span class="s3">'%s.dist-info' </span><span class="s1">% name_ver</span>
        <span class="s1">arcname = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'EXTENSIONS'</span><span class="s1">)</span>
        <span class="s1">wrapper = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
        <span class="s1">result = []</span>
        <span class="s2">with </span><span class="s1">ZipFile(pathname</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">zf:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">with </span><span class="s1">zf.open(arcname) </span><span class="s2">as </span><span class="s1">bf:</span>
                    <span class="s1">wf = wrapper(bf)</span>
                    <span class="s1">extensions = json.load(wf)</span>
                    <span class="s1">cache = self._get_dylib_cache()</span>
                    <span class="s1">prefix = cache.prefix_to_dir(pathname)</span>
                    <span class="s1">cache_base = os.path.join(cache.base</span><span class="s2">, </span><span class="s1">prefix)</span>
                    <span class="s2">if not </span><span class="s1">os.path.isdir(cache_base):</span>
                        <span class="s1">os.makedirs(cache_base)</span>
                    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">relpath </span><span class="s2">in </span><span class="s1">extensions.items():</span>
                        <span class="s1">dest = os.path.join(cache_base</span><span class="s2">, </span><span class="s1">convert_path(relpath))</span>
                        <span class="s2">if not </span><span class="s1">os.path.exists(dest):</span>
                            <span class="s1">extract = </span><span class="s2">True</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">file_time = os.stat(dest).st_mtime</span>
                            <span class="s1">file_time = datetime.datetime.fromtimestamp(file_time)</span>
                            <span class="s1">info = zf.getinfo(relpath)</span>
                            <span class="s1">wheel_time = datetime.datetime(*info.date_time)</span>
                            <span class="s1">extract = wheel_time &gt; file_time</span>
                        <span class="s2">if </span><span class="s1">extract:</span>
                            <span class="s1">zf.extract(relpath</span><span class="s2">, </span><span class="s1">cache_base)</span>
                        <span class="s1">result.append((name</span><span class="s2">, </span><span class="s1">dest))</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">is_compatible(self):</span>
        <span class="s6">&quot;&quot;&quot; 
        Determine if a wheel is compatible with the running system. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">is_compatible(self)</span>

    <span class="s2">def </span><span class="s1">is_mountable(self):</span>
        <span class="s6">&quot;&quot;&quot; 
        Determine if a wheel is asserted as mountable by its metadata. 
        &quot;&quot;&quot;</span>
        <span class="s2">return True </span><span class="s0"># for now - metadata details TBD</span>

    <span class="s2">def </span><span class="s1">mount(self</span><span class="s2">, </span><span class="s1">append=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">pathname = os.path.abspath(os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename))</span>
        <span class="s2">if not </span><span class="s1">self.is_compatible():</span>
            <span class="s1">msg = </span><span class="s3">'Wheel %s not compatible with this Python.' </span><span class="s1">% pathname</span>
            <span class="s2">raise </span><span class="s1">DistlibException(msg)</span>
        <span class="s2">if not </span><span class="s1">self.is_mountable():</span>
            <span class="s1">msg = </span><span class="s3">'Wheel %s is marked as not mountable.' </span><span class="s1">% pathname</span>
            <span class="s2">raise </span><span class="s1">DistlibException(msg)</span>
        <span class="s2">if </span><span class="s1">pathname </span><span class="s2">in </span><span class="s1">sys.path:</span>
            <span class="s1">logger.debug(</span><span class="s3">'%s already in path'</span><span class="s2">, </span><span class="s1">pathname)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">append:</span>
                <span class="s1">sys.path.append(pathname)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">sys.path.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">pathname)</span>
            <span class="s1">extensions = self._get_extensions()</span>
            <span class="s2">if </span><span class="s1">extensions:</span>
                <span class="s2">if </span><span class="s1">_hook </span><span class="s2">not in </span><span class="s1">sys.meta_path:</span>
                    <span class="s1">sys.meta_path.append(_hook)</span>
                <span class="s1">_hook.add(pathname</span><span class="s2">, </span><span class="s1">extensions)</span>

    <span class="s2">def </span><span class="s1">unmount(self):</span>
        <span class="s1">pathname = os.path.abspath(os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename))</span>
        <span class="s2">if </span><span class="s1">pathname </span><span class="s2">not in </span><span class="s1">sys.path:</span>
            <span class="s1">logger.debug(</span><span class="s3">'%s not in path'</span><span class="s2">, </span><span class="s1">pathname)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sys.path.remove(pathname)</span>
            <span class="s2">if </span><span class="s1">pathname </span><span class="s2">in </span><span class="s1">_hook.impure_wheels:</span>
                <span class="s1">_hook.remove(pathname)</span>
            <span class="s2">if not </span><span class="s1">_hook.impure_wheels:</span>
                <span class="s2">if </span><span class="s1">_hook </span><span class="s2">in </span><span class="s1">sys.meta_path:</span>
                    <span class="s1">sys.meta_path.remove(_hook)</span>

    <span class="s2">def </span><span class="s1">verify(self):</span>
        <span class="s1">pathname = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s1">name_ver = </span><span class="s3">'%s-%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.version)</span>
        <span class="s1">data_dir = </span><span class="s3">'%s.data' </span><span class="s1">% name_ver</span>
        <span class="s1">info_dir = </span><span class="s3">'%s.dist-info' </span><span class="s1">% name_ver</span>

        <span class="s1">metadata_name = posixpath.join(info_dir</span><span class="s2">, </span><span class="s1">LEGACY_METADATA_FILENAME)</span>
        <span class="s1">wheel_metadata_name = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'WHEEL'</span><span class="s1">)</span>
        <span class="s1">record_name = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'RECORD'</span><span class="s1">)</span>

        <span class="s1">wrapper = codecs.getreader(</span><span class="s3">'utf-8'</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">ZipFile(pathname</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">zf:</span>
            <span class="s2">with </span><span class="s1">zf.open(wheel_metadata_name) </span><span class="s2">as </span><span class="s1">bwf:</span>
                <span class="s1">wf = wrapper(bwf)</span>
                <span class="s1">message = message_from_file(wf)</span>
            <span class="s1">wv = message[</span><span class="s3">'Wheel-Version'</span><span class="s1">].split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">file_version = tuple([int(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">wv])</span>
            <span class="s0"># TODO version verification</span>

            <span class="s1">records = {}</span>
            <span class="s2">with </span><span class="s1">zf.open(record_name) </span><span class="s2">as </span><span class="s1">bf:</span>
                <span class="s2">with </span><span class="s1">CSVReader(stream=bf) </span><span class="s2">as </span><span class="s1">reader:</span>
                    <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">reader:</span>
                        <span class="s1">p = row[</span><span class="s4">0</span><span class="s1">]</span>
                        <span class="s1">records[p] = row</span>

            <span class="s2">for </span><span class="s1">zinfo </span><span class="s2">in </span><span class="s1">zf.infolist():</span>
                <span class="s1">arcname = zinfo.filename</span>
                <span class="s2">if </span><span class="s1">isinstance(arcname</span><span class="s2">, </span><span class="s1">text_type):</span>
                    <span class="s1">u_arcname = arcname</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">u_arcname = arcname.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
                <span class="s0"># See issue #115: some wheels have .. in their entries, but</span>
                <span class="s0"># in the filename ... e.g. __main__..py ! So the check is</span>
                <span class="s0"># updated to look for .. in the directory portions</span>
                <span class="s1">p = u_arcname.split(</span><span class="s3">'/'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s3">'..' </span><span class="s2">in </span><span class="s1">p:</span>
                    <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'invalid entry in '</span>
                                           <span class="s3">'wheel: %r' </span><span class="s1">% u_arcname)</span>

                <span class="s2">if </span><span class="s1">self.skip_entry(u_arcname):</span>
                    <span class="s2">continue</span>
                <span class="s1">row = records[u_arcname]</span>
                <span class="s2">if </span><span class="s1">row[</span><span class="s4">2</span><span class="s1">] </span><span class="s2">and </span><span class="s1">str(zinfo.file_size) != row[</span><span class="s4">2</span><span class="s1">]:</span>
                    <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'size mismatch for '</span>
                                           <span class="s3">'%s' </span><span class="s1">% u_arcname)</span>
                <span class="s2">if </span><span class="s1">row[</span><span class="s4">1</span><span class="s1">]:</span>
                    <span class="s1">kind</span><span class="s2">, </span><span class="s1">value = row[</span><span class="s4">1</span><span class="s1">].split(</span><span class="s3">'='</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s2">with </span><span class="s1">zf.open(arcname) </span><span class="s2">as </span><span class="s1">bf:</span>
                        <span class="s1">data = bf.read()</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">digest = self.get_hash(data</span><span class="s2">, </span><span class="s1">kind)</span>
                    <span class="s2">if </span><span class="s1">digest != value:</span>
                        <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'digest mismatch for '</span>
                                               <span class="s3">'%s' </span><span class="s1">% arcname)</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">modifier</span><span class="s2">, </span><span class="s1">dest_dir=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s6">&quot;&quot;&quot; 
        Update the contents of a wheel in a generic way. The modifier should 
        be a callable which expects a dictionary argument: its keys are 
        archive-entry paths, and its values are absolute filesystem paths 
        where the contents the corresponding archive entries can be found. The 
        modifier is free to change the contents of the files pointed to, add 
        new entries and remove entries, before returning. This method will 
        extract the entire contents of the wheel to a temporary location, call 
        the modifier, and then use the passed (and possibly updated) 
        dictionary to write a new wheel. If ``dest_dir`` is specified, the new 
        wheel is written there -- otherwise, the original wheel is overwritten. 
 
        The modifier should return True if it updated the wheel, else False. 
        This method returns the same value the modifier returns. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">get_version(path_map</span><span class="s2">, </span><span class="s1">info_dir):</span>
            <span class="s1">version = path = </span><span class="s2">None</span>
            <span class="s1">key = </span><span class="s3">'%s/%s' </span><span class="s1">% (info_dir</span><span class="s2">, </span><span class="s1">LEGACY_METADATA_FILENAME)</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">path_map:</span>
                <span class="s1">key = </span><span class="s3">'%s/PKG-INFO' </span><span class="s1">% info_dir</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">path_map:</span>
                <span class="s1">path = path_map[key]</span>
                <span class="s1">version = Metadata(path=path).version</span>
            <span class="s2">return </span><span class="s1">version</span><span class="s2">, </span><span class="s1">path</span>

        <span class="s2">def </span><span class="s1">update_version(version</span><span class="s2">, </span><span class="s1">path):</span>
            <span class="s1">updated = </span><span class="s2">None</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">v = NormalizedVersion(version)</span>
                <span class="s1">i = version.find(</span><span class="s3">'-'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">i &lt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">updated = </span><span class="s3">'%s+1' </span><span class="s1">% version</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">parts = [int(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">version[i + </span><span class="s4">1</span><span class="s1">:].split(</span><span class="s3">'.'</span><span class="s1">)]</span>
                    <span class="s1">parts[-</span><span class="s4">1</span><span class="s1">] += </span><span class="s4">1</span>
                    <span class="s1">updated = </span><span class="s3">'%s+%s' </span><span class="s1">% (version[:i]</span><span class="s2">,</span>
                                         <span class="s3">'.'</span><span class="s1">.join(str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">parts))</span>
            <span class="s2">except </span><span class="s1">UnsupportedVersionError:</span>
                <span class="s1">logger.debug(</span><span class="s3">'Cannot update non-compliant (PEP-440) '</span>
                             <span class="s3">'version %r'</span><span class="s2">, </span><span class="s1">version)</span>
            <span class="s2">if </span><span class="s1">updated:</span>
                <span class="s1">md = Metadata(path=path)</span>
                <span class="s1">md.version = updated</span>
                <span class="s1">legacy = path.endswith(LEGACY_METADATA_FILENAME)</span>
                <span class="s1">md.write(path=path</span><span class="s2">, </span><span class="s1">legacy=legacy)</span>
                <span class="s1">logger.debug(</span><span class="s3">'Version updated from %r to %r'</span><span class="s2">, </span><span class="s1">version</span><span class="s2">,</span>
                             <span class="s1">updated)</span>

        <span class="s1">pathname = os.path.join(self.dirname</span><span class="s2">, </span><span class="s1">self.filename)</span>
        <span class="s1">name_ver = </span><span class="s3">'%s-%s' </span><span class="s1">% (self.name</span><span class="s2">, </span><span class="s1">self.version)</span>
        <span class="s1">info_dir = </span><span class="s3">'%s.dist-info' </span><span class="s1">% name_ver</span>
        <span class="s1">record_name = posixpath.join(info_dir</span><span class="s2">, </span><span class="s3">'RECORD'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">tempdir() </span><span class="s2">as </span><span class="s1">workdir:</span>
            <span class="s2">with </span><span class="s1">ZipFile(pathname</span><span class="s2">, </span><span class="s3">'r'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">zf:</span>
                <span class="s1">path_map = {}</span>
                <span class="s2">for </span><span class="s1">zinfo </span><span class="s2">in </span><span class="s1">zf.infolist():</span>
                    <span class="s1">arcname = zinfo.filename</span>
                    <span class="s2">if </span><span class="s1">isinstance(arcname</span><span class="s2">, </span><span class="s1">text_type):</span>
                        <span class="s1">u_arcname = arcname</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">u_arcname = arcname.decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">u_arcname == record_name:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s3">'..' </span><span class="s2">in </span><span class="s1">u_arcname:</span>
                        <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'invalid entry in '</span>
                                               <span class="s3">'wheel: %r' </span><span class="s1">% u_arcname)</span>
                    <span class="s1">zf.extract(zinfo</span><span class="s2">, </span><span class="s1">workdir)</span>
                    <span class="s1">path = os.path.join(workdir</span><span class="s2">, </span><span class="s1">convert_path(u_arcname))</span>
                    <span class="s1">path_map[u_arcname] = path</span>

            <span class="s0"># Remember the version.</span>
            <span class="s1">original_version</span><span class="s2">, </span><span class="s1">_ = get_version(path_map</span><span class="s2">, </span><span class="s1">info_dir)</span>
            <span class="s0"># Files extracted. Call the modifier.</span>
            <span class="s1">modified = modifier(path_map</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">modified:</span>
                <span class="s0"># Something changed - need to build a new wheel.</span>
                <span class="s1">current_version</span><span class="s2">, </span><span class="s1">path = get_version(path_map</span><span class="s2">, </span><span class="s1">info_dir)</span>
                <span class="s2">if </span><span class="s1">current_version </span><span class="s2">and </span><span class="s1">(current_version == original_version):</span>
                    <span class="s0"># Add or update local version to signify changes.</span>
                    <span class="s1">update_version(current_version</span><span class="s2">, </span><span class="s1">path)</span>
                <span class="s0"># Decide where the new wheel goes.</span>
                <span class="s2">if </span><span class="s1">dest_dir </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">fd</span><span class="s2">, </span><span class="s1">newpath = tempfile.mkstemp(suffix=</span><span class="s3">'.whl'</span><span class="s2">,</span>
                                                   <span class="s1">prefix=</span><span class="s3">'wheel-update-'</span><span class="s2">,</span>
                                                   <span class="s1">dir=workdir)</span>
                    <span class="s1">os.close(fd)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if not </span><span class="s1">os.path.isdir(dest_dir):</span>
                        <span class="s2">raise </span><span class="s1">DistlibException(</span><span class="s3">'Not a directory: %r' </span><span class="s1">% dest_dir)</span>
                    <span class="s1">newpath = os.path.join(dest_dir</span><span class="s2">, </span><span class="s1">self.filename)</span>
                <span class="s1">archive_paths = list(path_map.items())</span>
                <span class="s1">distinfo = os.path.join(workdir</span><span class="s2">, </span><span class="s1">info_dir)</span>
                <span class="s1">info = distinfo</span><span class="s2">, </span><span class="s1">info_dir</span>
                <span class="s1">self.write_records(info</span><span class="s2">, </span><span class="s1">workdir</span><span class="s2">, </span><span class="s1">archive_paths)</span>
                <span class="s1">self.build_zip(newpath</span><span class="s2">, </span><span class="s1">archive_paths)</span>
                <span class="s2">if </span><span class="s1">dest_dir </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">shutil.copyfile(newpath</span><span class="s2">, </span><span class="s1">pathname)</span>
        <span class="s2">return </span><span class="s1">modified</span>

<span class="s2">def </span><span class="s1">_get_glibc_version():</span>
    <span class="s2">import </span><span class="s1">platform</span>
    <span class="s1">ver = platform.libc_ver()</span>
    <span class="s1">result = []</span>
    <span class="s2">if </span><span class="s1">ver[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'glibc'</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">ver[</span><span class="s4">1</span><span class="s1">].split(</span><span class="s3">'.'</span><span class="s1">):</span>
            <span class="s1">result.append(int(s) </span><span class="s2">if </span><span class="s1">s.isdigit() </span><span class="s2">else </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">result = tuple(result)</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s2">def </span><span class="s1">compatible_tags():</span>
    <span class="s6">&quot;&quot;&quot; 
    Return (pyver, abi, arch) tuples compatible with this Python. 
    &quot;&quot;&quot;</span>
    <span class="s1">versions = [VER_SUFFIX]</span>
    <span class="s1">major = VER_SUFFIX[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">minor </span><span class="s2">in </span><span class="s1">range(sys.version_info[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">- </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">versions.append(</span><span class="s3">''</span><span class="s1">.join([major</span><span class="s2">, </span><span class="s1">str(minor)]))</span>

    <span class="s1">abis = []</span>
    <span class="s2">for </span><span class="s1">suffix</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">imp.get_suffixes():</span>
        <span class="s2">if </span><span class="s1">suffix.startswith(</span><span class="s3">'.abi'</span><span class="s1">):</span>
            <span class="s1">abis.append(suffix.split(</span><span class="s3">'.'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">abis.sort()</span>
    <span class="s2">if </span><span class="s1">ABI != </span><span class="s3">'none'</span><span class="s1">:</span>
        <span class="s1">abis.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">ABI)</span>
    <span class="s1">abis.append(</span><span class="s3">'none'</span><span class="s1">)</span>
    <span class="s1">result = []</span>

    <span class="s1">arches = [ARCH]</span>
    <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s3">'darwin'</span><span class="s1">:</span>
        <span class="s1">m = re.match(</span><span class="s3">r'(\w+)_(\d+)_(\d+)_(\w+)$'</span><span class="s2">, </span><span class="s1">ARCH)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">major</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">arch = m.groups()</span>
            <span class="s1">minor = int(minor)</span>
            <span class="s1">matches = [arch]</span>
            <span class="s2">if </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'i386'</span><span class="s2">, </span><span class="s3">'ppc'</span><span class="s1">):</span>
                <span class="s1">matches.append(</span><span class="s3">'fat'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'i386'</span><span class="s2">, </span><span class="s3">'ppc'</span><span class="s2">, </span><span class="s3">'x86_64'</span><span class="s1">):</span>
                <span class="s1">matches.append(</span><span class="s3">'fat3'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'ppc64'</span><span class="s2">, </span><span class="s3">'x86_64'</span><span class="s1">):</span>
                <span class="s1">matches.append(</span><span class="s3">'fat64'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'i386'</span><span class="s2">, </span><span class="s3">'x86_64'</span><span class="s1">):</span>
                <span class="s1">matches.append(</span><span class="s3">'intel'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'i386'</span><span class="s2">, </span><span class="s3">'x86_64'</span><span class="s2">, </span><span class="s3">'intel'</span><span class="s2">, </span><span class="s3">'ppc'</span><span class="s2">, </span><span class="s3">'ppc64'</span><span class="s1">):</span>
                <span class="s1">matches.append(</span><span class="s3">'universal'</span><span class="s1">)</span>
            <span class="s2">while </span><span class="s1">minor &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">matches:</span>
                    <span class="s1">s = </span><span class="s3">'%s_%s_%s_%s' </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">major</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">match)</span>
                    <span class="s2">if </span><span class="s1">s != ARCH:   </span><span class="s0"># already there</span>
                        <span class="s1">arches.append(s)</span>
                <span class="s1">minor -= </span><span class="s4">1</span>

    <span class="s0"># Most specific - our Python version, ABI and arch</span>
    <span class="s2">for </span><span class="s1">abi </span><span class="s2">in </span><span class="s1">abis:</span>
        <span class="s2">for </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">arches:</span>
            <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((IMP_PREFIX</span><span class="s2">, </span><span class="s1">versions[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">, </span><span class="s1">arch))</span>
            <span class="s0"># manylinux</span>
            <span class="s2">if </span><span class="s1">abi != </span><span class="s3">'none' </span><span class="s2">and </span><span class="s1">sys.platform.startswith(</span><span class="s3">'linux'</span><span class="s1">):</span>
                <span class="s1">arch = arch.replace(</span><span class="s3">'linux_'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
                <span class="s1">parts = _get_glibc_version()</span>
                <span class="s2">if </span><span class="s1">len(parts) == </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">parts &gt;= (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">):</span>
                        <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((IMP_PREFIX</span><span class="s2">, </span><span class="s1">versions[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">,</span>
                                       <span class="s3">'manylinux1_%s' </span><span class="s1">% arch))</span>
                    <span class="s2">if </span><span class="s1">parts &gt;= (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">12</span><span class="s1">):</span>
                        <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((IMP_PREFIX</span><span class="s2">, </span><span class="s1">versions[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">,</span>
                                       <span class="s3">'manylinux2010_%s' </span><span class="s1">% arch))</span>
                    <span class="s2">if </span><span class="s1">parts &gt;= (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">17</span><span class="s1">):</span>
                        <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((IMP_PREFIX</span><span class="s2">, </span><span class="s1">versions[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">,</span>
                                       <span class="s3">'manylinux2014_%s' </span><span class="s1">% arch))</span>
                    <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((IMP_PREFIX</span><span class="s2">, </span><span class="s1">versions[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">,</span>
                                   <span class="s3">'manylinux_%s_%s_%s' </span><span class="s1">% (parts[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">parts[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                                           <span class="s1">arch)))</span>

    <span class="s0"># where no ABI / arch dependency, but IMP_PREFIX dependency</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">version </span><span class="s2">in </span><span class="s1">enumerate(versions):</span>
        <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((IMP_PREFIX</span><span class="s2">, </span><span class="s1">version))</span><span class="s2">, </span><span class="s3">'none'</span><span class="s2">, </span><span class="s3">'any'</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((IMP_PREFIX</span><span class="s2">, </span><span class="s1">version[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">, </span><span class="s3">'none'</span><span class="s2">, </span><span class="s3">'any'</span><span class="s1">))</span>

    <span class="s0"># no IMP_PREFIX, ABI or arch dependency</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">version </span><span class="s2">in </span><span class="s1">enumerate(versions):</span>
        <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((</span><span class="s3">'py'</span><span class="s2">, </span><span class="s1">version))</span><span class="s2">, </span><span class="s3">'none'</span><span class="s2">, </span><span class="s3">'any'</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">result.append((</span><span class="s3">''</span><span class="s1">.join((</span><span class="s3">'py'</span><span class="s2">, </span><span class="s1">version[</span><span class="s4">0</span><span class="s1">]))</span><span class="s2">, </span><span class="s3">'none'</span><span class="s2">, </span><span class="s3">'any'</span><span class="s1">))</span>

    <span class="s2">return </span><span class="s1">set(result)</span>


<span class="s1">COMPATIBLE_TAGS = compatible_tags()</span>

<span class="s2">del </span><span class="s1">compatible_tags</span>


<span class="s2">def </span><span class="s1">is_compatible(wheel</span><span class="s2">, </span><span class="s1">tags=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if not </span><span class="s1">isinstance(wheel</span><span class="s2">, </span><span class="s1">Wheel):</span>
        <span class="s1">wheel = Wheel(wheel)    </span><span class="s0"># assume it's a filename</span>
    <span class="s1">result = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s1">tags </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">tags = COMPATIBLE_TAGS</span>
    <span class="s2">for </span><span class="s1">ver</span><span class="s2">, </span><span class="s1">abi</span><span class="s2">, </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">tags:</span>
        <span class="s2">if </span><span class="s1">ver </span><span class="s2">in </span><span class="s1">wheel.pyver </span><span class="s2">and </span><span class="s1">abi </span><span class="s2">in </span><span class="s1">wheel.abi </span><span class="s2">and </span><span class="s1">arch </span><span class="s2">in </span><span class="s1">wheel.arch:</span>
            <span class="s1">result = </span><span class="s2">True</span>
            <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">result</span>
</pre>
</body>
</html>